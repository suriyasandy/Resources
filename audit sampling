import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import numpy as np
from math import ceil
from datetime import datetime
import os

# ==============================
# CONFIG
# ==============================
MIN_SAMPLE = 300
MAX_SAMPLE = 350
EXPORT_DIR = "QA_Sampling_Output"
os.makedirs(EXPORT_DIR, exist_ok=True)

# ==============================
# CORE SAMPLING LOGIC
# ==============================
def build_strata(df, cols):
    df["_STRATUM_"] = df[cols].astype(str).agg(" | ".join, axis=1)
    return df

def target_sample_size(strata_count):
    return min(MAX_SAMPLE, max(MIN_SAMPLE, strata_count))

def neyman_allocation_strict(stats, total_records, target_n):
    """
    STRICT allocation:
    - If strata <= target_n â†’ every stratum gets at least 1
    - Remaining samples distributed proportionally by risk
    - NO stratum can ever drop below 1
    """

    strata_count = len(stats)

    # Risk weight
    stats["risk_weight"] = stats["records"] / total_records

    # ---------- CASE 1: FULL STRATA COVERAGE ----------
    if strata_count <= target_n:
        # Step 1: baseline = 1 per stratum
        stats["sample_alloc"] = 1

        remaining = target_n - strata_count
        if remaining > 0:
            # Step 2: proportional top-up
            stats["extra"] = (stats["risk_weight"] * remaining).round().astype(int)

            # Fix rounding drift
            drift = remaining - stats["extra"].sum()
            if drift > 0:
                stats.loc[
                    stats.sort_values("records", ascending=False).head(drift).index,
                    "extra"
                ] += 1

            stats["sample_alloc"] += stats["extra"]
            stats.drop(columns=["extra"], inplace=True)

        return stats

    # ---------- CASE 2: PARTIAL COVERAGE ----------
    stats["sample_alloc"] = (stats["risk_weight"] * target_n).round().astype(int)
    stats.loc[stats["sample_alloc"] < 1, "sample_alloc"] = 1

    # Adjust only if we exceeded target
    diff = stats["sample_alloc"].sum() - target_n
    if diff > 0:
        reducible = stats[stats["sample_alloc"] > 1].sort_toggle("records")
        for idx in reducible.index:
            if diff == 0:
                break
            stats.at[idx, "sample_alloc"] -= 1
            diff -= 1

    return stats

def stratified_sample(df, allocation):
    sampled_idx = []

    for _, row in allocation.iterrows():
        pool = df[df["_STRATUM_"] == row["_STRATUM_"]]
        take = min(row["sample_alloc"], len(pool))
        sampled_idx.extend(pool.sample(take, random_state=42).index)

    sampled = df.loc[sampled_idx]
    unsampled = df.drop(sampled_idx)
    return sampled, unsampled

# ==============================
# TKINTER QA TOOL
# ==============================
class QASamplingApp:

    def __init__(self, root):
        self.root = root
        root.title("QA Risk-Based Sampling Tool (Ops Ready)")
        root.geometry("1650x900")

        self.df = None
        self.sampled = None
        self.unsampled = None
        self.stats = None

        self.build_ui()

    # --------------------------
    def build_ui(self):
        nb = ttk.Notebook(self.root)
        nb.pack(fill="both", expand=True)

        self.tab_data = ttk.Frame(nb)
        self.tab_results = ttk.Frame(nb)
        self.tab_export = ttk.Frame(nb)
        self.tab_docs = ttk.Frame(nb)

        nb.add(self.tab_data, text="ðŸ“Š Data & Strata")
        nb.add(self.tab_results, text="ðŸ“ˆ Sampling Results")
        nb.add(self.tab_export, text="ðŸ’¾ Export")
        nb.add(self.tab_docs, text="ðŸ“˜ Methodology")

        self.build_tab_data()
        self.build_tab_results()
        self.build_tab_export()
        self.build_tab_docs()

    # --------------------------
    def build_tab_data(self):
        top = ttk.Frame(self.tab_data, padding=10)
        top.pack(fill="x")

        ttk.Button(top, text="Load Dataset", command=self.load_data).pack(side="left")

        ttk.Label(top, text="Region").pack(side="left", padx=5)
        self.region_cb = ttk.Combobox(top, width=18)
        self.region_cb.pack(side="left")

        ttk.Label(top, text="Product").pack(side="left", padx=5)
        self.product_cb = ttk.Combobox(top, width=18)
        self.product_cb.pack(side="left")

        ttk.Button(top, text="Run QA Sampling", command=self.run_sampling).pack(side="right")

        mid = ttk.Frame(self.tab_data)
        mid.pack(fill="both", expand=True)

        left = ttk.LabelFrame(mid, text="Optional Additional Columns", padding=5)
        left.pack(side="left", fill="y")

        self.additional_lb = tk.Listbox(left, selectmode="multiple", height=12)
        self.additional_lb.pack(fill="y")

        right = ttk.LabelFrame(mid, text="Dataset Preview (200 rows)", padding=5)
        right.pack(side="right", fill="both", expand=True)

        self.preview = ttk.Treeview(right)
        vsb = ttk.Scrollbar(right, orient="vertical", command=self.preview.yview)
        hsb = ttk.Scrollbar(right, orient="horizontal", command=self.preview.xview)
        self.preview.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        self.preview.pack(fill="both", expand=True)
        vsb.pack(side="right", fill="y")
        hsb.pack(side="bottom", fill="x")

    # --------------------------
    def build_tab_results(self):
        top = ttk.Frame(self.tab_results, padding=10)
        top.pack(fill="x")

        self.summary = tk.Text(top, height=6, font=("Courier", 10))
        self.summary.pack(fill="x")

        bottom = ttk.LabelFrame(self.tab_results, text="Stratum Risk Allocation")
        bottom.pack(fill="both", expand=True)

        self.table = ttk.Treeview(bottom)
        vsb = ttk.Scrollbar(bottom, orient="vertical", command=self.table.yview)
        self.table.configure(yscrollcommand=vsb.set)

        self.table.pack(fill="both", expand=True)
        vsb.pack(side="right", fill="y")

    # --------------------------
    def build_tab_export(self):
        frame = ttk.Frame(self.tab_export, padding=10)
        frame.pack(fill="both", expand=True)

        ttk.Button(frame, text="Export QA Outputs", command=self.export_all).pack()
        self.export_log = tk.Text(frame, height=10)
        self.export_log.pack(fill="both", expand=True)

    # --------------------------
    def build_tab_docs(self):
        text = tk.Text(self.tab_docs, font=("Courier", 10))
        text.pack(fill="both", expand=True)
        text.insert("end", """
QA SAMPLING METHODOLOGY (OPS APPROVED)

1. Mandatory Region + Product stratification
2. Optional additional dimensions increase strata
3. One sample minimum per stratum (coverage guarantee)
4. Expected sample size between 300â€“350
5. Neyman proportional allocation by population
6. Controlled random sampling within each stratum
7. Fully auditable & reproducible
""")

    # --------------------------
    def load_data(self):
        path = filedialog.askopenfilename(filetypes=[("CSV / Excel", "*.csv *.xlsx")])
        if not path:
            return

        self.df = pd.read_csv(path) if path.endswith(".csv") else pd.read_excel(path)
        cols = list(self.df.columns)

        self.region_cb["values"] = cols
        self.product_cb["values"] = cols
        self.region_cb.set(cols[0])
        self.product_cb.set(cols[1])

        self.additional_lb.delete(0, tk.END)
        for c in cols:
            self.additional_lb.insert(tk.END, c)

        self.show_preview(self.df.head(200))

    # --------------------------
    def show_preview(self, df):
        self.preview.delete(*self.preview.get_children())
        self.preview["columns"] = list(df.columns)
        self.preview["show"] = "headings"

        for c in df.columns:
            self.preview.heading(c, text=c)
            self.preview.column(c, width=120)

        for _, row in df.iterrows():
            self.preview.insert("", "end", values=list(row))

    # --------------------------
    def run_sampling(self):
        region = self.region_cb.get()
        product = self.product_cb.get()

        if not region or not product:
            messagebox.showerror("Error", "Region & Product are mandatory")
            return

        additional = [
            self.additional_lb.get(i)
            for i in self.additional_lb.curselection()
            if self.additional_lb.get(i) not in (region, product)
        ]

        df = build_strata(self.df.copy(), [region, product] + additional)
        stats = df.groupby("_STRATUM_").size().reset_index(name="records")

        target_n = target_sample_size(len(stats))
        allocation = neyman_allocation(stats, len(df), target_n)

        self.sampled, self.unsampled = stratified_sample(df, allocation)
        self.stats = allocation

        self.display_results()

    # --------------------------
    def display_results(self):
        self.summary.delete("1.0", tk.END)
        self.summary.insert("end", f"""
TOTAL RECORDS      : {len(self.df)}
TOTAL STRATA       : {len(self.stats)}
TARGET SAMPLE SIZE : {target_sample_size(len(self.stats))}
ACTUAL SAMPLE SIZE : {len(self.sampled)}
UNSAMPLED RECORDS  : {len(self.unsampled)}
""")

        self.table.delete(*self.table.get_children())
        self.table["columns"] = list(self.stats.columns)
        self.table["show"] = "headings"

        for c in self.stats.columns:
            self.table.heading(c, text=c)
            self.table.column(c, width=220)

        for _, row in self.stats.iterrows():
            self.table.insert("", "end", values=list(row))

    # --------------------------
    def export_all(self):
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")

        self.sampled.to_excel(f"{EXPORT_DIR}/sampled_{ts}.xlsx", index=False)
        self.unsampled.to_excel(f"{EXPORT_DIR}/unsampled_{ts}.xlsx", index=False)
        self.stats.to_excel(f"{EXPORT_DIR}/stratum_stats_{ts}.xlsx", index=False)

        self.export_log.insert("end", "QA sampling outputs exported successfully\n")

# ==============================
# RUN
# ==============================
if __name__ == "__main__":
    root = tk.Tk()
    QASamplingApp(root)
    root.mainloop()
