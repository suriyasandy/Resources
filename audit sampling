#!/usr/bin/env python3
"""
OMRC v8.9 - FINAL PRODUCTION CODE WITH AUTOMATIC SAMPLE SIZE CALCULATION
Complete Audit Sampling Tool - Error-Proof & Production Ready

Changes for auditor request:
- Removed demo sample generator
- Sample size = auto-calculated and used consistently across methods
- Seed-per-stratum option for stratified methods (Proportional & Neyman)
- SRS has no per-stratum seeding (random every run)
- Export Covered Samples, Export Missed Strata, Export Out-of-Scope (missed by ALL)
- Run summary text file (contains formulas, assumptions, exported filenames)
- Always export missed strata CSV per method even when empty
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, Toplevel, Listbox, MULTIPLE
import pandas as pd
import numpy as np
from datetime import datetime
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import seaborn as sns
import warnings
from scipy import stats

warnings.filterwarnings('ignore')
plt.style.use('default')
sns.set_palette("Set2")


class OMRCRiskBasedSamplingTool:
    """OMRC v8.9 - Final Production with Auto Sample Size & Error Handling"""

    def __init__(self, root, out_dir_path):
        self.root = root
        self.root.title("OMRC Audit Sampling Tool v8.9 - Production Ready")
        self.root.geometry("1700x1050")
        self.root.minsize(1200, 800)

        self.data = None
        self.comparison_results = {}
        self.selected_additional_columns = []
        self.stratum_stats = None
        self.calculated_sample_size = None

        self.results_dir = os.path.join(out_dir_path, "OMRC_Results")
        os.makedirs(self.results_dir, exist_ok=True)

        self.create_widgets()

    def create_widgets(self):
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill='both', expand=True, padx=10, pady=10)

        self.tab1 = ttk.Frame(notebook)
        notebook.add(self.tab1, text="1. Data & Configuration")

        self.tab2 = ttk.Frame(notebook)
        notebook.add(self.tab2, text="2. Risk Calculation")

        self.tab3 = ttk.Frame(notebook)
        notebook.add(self.tab3, text="3. Sampling & Results")

        self.tab4 = ttk.Frame(notebook)
        notebook.add(self.tab4, text="4. Coverage Analysis")

        self.tab5 = ttk.Frame(notebook)
        notebook.add(self.tab5, text="5. Visualizations")

        self.create_tab1_widgets()
        self.create_tab2_widgets()
        self.create_tab3_widgets()
        self.create_tab4_widgets()
        self.create_tab5_widgets()

    def create_tab1_widgets(self):
        """Tab 1: Data Loading & Configuration"""

        data_frame = ttk.LabelFrame(self.tab1, text="Data Loading", padding="10")
        data_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)

        ttk.Button(data_frame, text="Load Data", command=self.load_data).grid(row=0, column=0, padx=5)

        self.data_label = ttk.Label(data_frame, text="No data loaded", font=('Arial', 10, 'bold'), foreground='blue')
        self.data_label.grid(row=1, column=0, columnspan=2, pady=5, sticky=tk.W)

        mandatory_frame = ttk.LabelFrame(self.tab1, text="MANDATORY COLUMNS", padding="10")
        mandatory_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)

        ttk.Label(mandatory_frame, text="Entity Column:").grid(row=0, column=0, sticky=tk.W)
        self.entity_col_var = tk.StringVar(value="legal_entity")
        self.entity_col_combo = ttk.Combobox(mandatory_frame, textvariable=self.entity_col_var, width=25)
        self.entity_col_combo.grid(row=0, column=1, padx=5)

        ttk.Label(mandatory_frame, text="Region Column:").grid(row=0, column=2, sticky=tk.W, padx=(20, 0))
        self.region_col_var = tk.StringVar(value="region")
        self.region_col_combo = ttk.Combobox(mandatory_frame, textvariable=self.region_col_var, width=25)
        self.region_col_combo.grid(row=0, column=3, padx=5)

        ttk.Label(mandatory_frame, text="Product Column:").grid(row=1, column=0, sticky=tk.W)
        self.product_col_var = tk.StringVar(value="product_type")
        self.product_col_combo = ttk.Combobox(mandatory_frame, textvariable=self.product_col_var, width=25)
        self.product_col_combo.grid(row=1, column=1, padx=5)

        additional_frame = ttk.LabelFrame(self.tab1, text="ADDITIONAL COLUMNS (Optional)", padding="10")
        additional_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)

        self.additional_cols_label = ttk.Label(additional_frame, text="None selected", foreground='gray')
        self.additional_cols_label.grid(row=0, column=0, sticky=tk.W, pady=5)

        ttk.Button(additional_frame, text="Select Additional Columns", command=self.open_column_selector).grid(row=1, column=0, pady=5, sticky=tk.W)

        preview_frame = ttk.LabelFrame(self.tab1, text="Data Preview", padding="10")
        preview_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)

        self.tree = ttk.Treeview(preview_frame)
        scrollbar_y = ttk.Scrollbar(preview_frame, orient="vertical", command=self.tree.yview)
        scrollbar_x = ttk.Scrollbar(preview_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
        scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))

        self.tab1.rowconfigure(3, weight=1)
        self.tab1.columnconfigure(0, weight=1)
        preview_frame.rowconfigure(0, weight=1)
        preview_frame.columnconfigure(0, weight=1)

    def create_tab2_widgets(self):
        """Tab 2: Risk Calculation"""

        main_frame = ttk.Frame(self.tab2)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)

        calc_frame = ttk.LabelFrame(main_frame, text="Risk Calculation & Sample Size Determination", padding="10")
        calc_frame.pack(fill='x', pady=(0, 10))

        ttk.Button(calc_frame, text="Calculate Risk Scores", command=self.calculate_risk_scores).pack(side='left', padx=5)

        self.risk_calc_label = ttk.Label(calc_frame, text="Not calculated", font=('Arial', 10, 'bold'), foreground='blue')
        self.risk_calc_label.pack(side='left', padx=10)

        # Sample size info frame
        sample_size_info = ttk.LabelFrame(main_frame, text="AUTOMATIC SAMPLE SIZE CALCULATION", padding="10")
        sample_size_info.pack(fill='x', pady=(0, 10))

        self.sample_size_info_label = ttk.Label(sample_size_info, text="Calculated automatically using Cochran formula with finite population correction", font=('Arial', 9))
        self.sample_size_info_label.pack(side='left', padx=10)

        self.calculated_size_label = ttk.Label(sample_size_info, text="Sample Size: --", font=('Arial', 11, 'bold'), foreground='green')
        self.calculated_size_label.pack(side='left', padx=20)

        risk_frame = ttk.LabelFrame(main_frame, text="Cumulative Risk Score by Stratum (DYNAMIC POPULATION)", padding="10")
        risk_frame.pack(fill='both', expand=True, pady=(0, 10))

        self.stratum_tree = ttk.Treeview(risk_frame,
                                        columns=("Stratum", "Population", "Avg_Risk", "High_Risk", "Risk_Level", "PopPercent", "StdDev"),
                                        show="tree headings", height=20)

        self.stratum_tree.heading("#0", text="")
        self.stratum_tree.heading("Stratum", text="Stratum (Entity|Region|Product)")
        self.stratum_tree.heading("Population", text="Population")
        self.stratum_tree.heading("Avg_Risk", text="Avg Risk")
        self.stratum_tree.heading("High_Risk", text="High Risk")
        self.stratum_tree.heading("Risk_Level", text="Risk Level")
        self.stratum_tree.heading("PopPercent", text="% of Total")
        self.stratum_tree.heading("StdDev", text="Std Dev")

        self.stratum_tree.column("#0", width=0)
        self.stratum_tree.column("Stratum", width=280)
        self.stratum_tree.column("Population", width=80)
        self.stratum_tree.column("Avg_Risk", width=80)
        self.stratum_tree.column("High_Risk", width=80)
        self.stratum_tree.column("Risk_Level", width=70)
        self.stratum_tree.column("PopPercent", width=80)
        self.stratum_tree.column("StdDev", width=80)

        stratum_scrollbar = ttk.Scrollbar(risk_frame, orient="vertical", command=self.stratum_tree.yview)
        self.stratum_tree.configure(yscrollcommand=stratum_scrollbar.set)

        self.stratum_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        stratum_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    def create_tab3_widgets(self):
        """Tab 3: Sampling & Results"""

        params_frame = ttk.LabelFrame(self.tab3, text="Parameters", padding="10")
        params_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)

        ttk.Label(params_frame, text="Confidence Level:").grid(row=0, column=0, sticky=tk.W)
        self.confidence_var = tk.StringVar(value="95%")
        ttk.Combobox(params_frame, textvariable=self.confidence_var, values=["90%", "95%", "99%"], width=10).grid(row=0, column=1, padx=5)

        ttk.Label(params_frame, text="Margin of Error:").grid(row=0, column=2, sticky=tk.W, padx=(20, 0))
        self.margin_error_var = tk.StringVar(value="5%")
        ttk.Combobox(params_frame, textvariable=self.margin_error_var, values=["1%", "2%", "5%", "10%"], width=10).grid(row=0, column=3, padx=5)

        self.seed_per_stratum_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(params_frame, text="Seed per stratum (for stratified methods)", variable=self.seed_per_stratum_var).grid(row=0, column=4, padx=(30, 0))

        self.auto_size_label = ttk.Label(params_frame, text="Sample Size: Auto-calculated", font=('Arial', 10, 'bold'), foreground='green')
        self.auto_size_label.grid(row=0, column=5, padx=(30, 0))

        methods_frame = ttk.LabelFrame(self.tab3, text="INDUSTRY-STANDARD SAMPLING METHODS", padding="10")
        methods_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)

        self.method_vars = {}
        descriptions = [
            ('Simple Random Sampling (SRS)', 'traditional', 'Pure random selection - baseline comparison'),
            ('Proportional Stratified Sampling', 'proportional', 'Allocates samples by stratum size (AICPA standard)'),
            ('Risk-Based Neyman Allocation', 'neyman', 'Optimizes based on stratum variability (ISA 530)'),
        ]

        for i, (name, key, desc) in enumerate(descriptions):
            var = tk.BooleanVar(value=True if i < 2 else False)
            self.method_vars[key] = var
            frame = ttk.Frame(methods_frame)
            frame.grid(row=i, column=0, sticky=tk.W, padx=20, pady=3)
            ttk.Checkbutton(frame, text=name, variable=var).pack(side='left')
            ttk.Label(frame, text=desc, font=('Arial', 8), foreground='gray').pack(side='left', padx=20)

        ttk.Button(methods_frame, text="Generate & Compare Samples",
                   command=self.generate_samples_enhanced).grid(row=4, column=0, pady=15, sticky=(tk.W, tk.E), padx=20)

        results_frame = ttk.LabelFrame(self.tab3, text="Results Summary", padding="10")
        results_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)

        self.summary_tree = ttk.Treeview(results_frame,
                                         columns=("Size", "High_Risk", "Avg_Risk", "Strata_Covered", "Method_Type"),
                                         show="tree headings", height=5)
        self.summary_tree.heading("#0", text="Method")
        self.summary_tree.heading("Size", text="Sample Size")
        self.summary_tree.heading("High_Risk", text="High Risk")
        self.summary_tree.heading("Avg_Risk", text="Avg Risk")
        self.summary_tree.heading("Strata_Covered", text="Strata Covered")
        self.summary_tree.heading("Method_Type", text="Methodology")

        for col in ["Size", "High_Risk", "Avg_Risk", "Strata_Covered", "Method_Type"]:
            self.summary_tree.column(col, width=110)

        self.summary_tree.pack(fill=tk.BOTH, expand=True)

        export_frame = ttk.Frame(results_frame)
        export_frame.pack(fill='x', pady=10)

        ttk.Button(export_frame, text="Export Covered Samples (all methods)", command=self.export_samples_covered).pack(side='left', padx=5)
        ttk.Button(export_frame, text="Export Missed Strata (all methods)", command=self.export_missed_strata_all).pack(side='left', padx=5)
        ttk.Button(export_frame, text="Export Out-of-Scope (missed by ALL)", command=self.export_out_of_scope).pack(side='left', padx=5)

        self.tab3.rowconfigure(2, weight=1)
        self.tab3.columnconfigure(0, weight=1)

    def create_tab4_widgets(self):
        """Tab 4: Coverage Analysis"""

        self.coverage_notebook = ttk.Notebook(self.tab4)
        self.coverage_notebook.pack(fill='both', expand=True, padx=10, pady=10)

        self.method_coverage_tabs = {}

        for display_name, method_key in [('Simple Random', 'traditional'),
                                         ('Proportional', 'proportional'),
                                         ('Neyman', 'neyman')]:
            method_frame = ttk.Frame(self.coverage_notebook)
            self.coverage_notebook.add(method_frame, text=display_name)

            sub_notebook = ttk.Notebook(method_frame)
            sub_notebook.pack(fill='both', expand=True, padx=5, pady=5)

            missed_frame = ttk.Frame(sub_notebook)
            sub_notebook.add(missed_frame, text="Missed Strata")

            missed_tree = ttk.Treeview(missed_frame, columns=("Stratum", "Population", "Avg_Risk"), show="tree headings")
            missed_tree.heading("#0", text="ID")
            missed_tree.heading("Stratum", text="Stratum")
            missed_tree.heading("Population", text="Population")
            missed_tree.heading("Avg_Risk", text="Avg Risk")

            for col in ["Stratum", "Population", "Avg_Risk"]:
                missed_tree.column(col, width=200)

            missed_scrollbar = ttk.Scrollbar(missed_frame, orient="vertical", command=missed_tree.yview)
            missed_tree.configure(yscrollcommand=missed_scrollbar.set)
            missed_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            missed_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            all_frame = ttk.Frame(sub_notebook)
            sub_notebook.add(all_frame, text="All Strata")

            all_tree = ttk.Treeview(all_frame, columns=("Stratum", "Population", "Sampled", "Coverage", "Avg_Risk", "AllocMethod"), show="tree headings")
            all_tree.heading("#0", text="ID")
            all_tree.heading("Stratum", text="Stratum")
            all_tree.heading("Population", text="Population")
            all_tree.heading("Sampled", text="Sampled")
            all_tree.heading("Coverage", text="Coverage %")
            all_tree.heading("Avg_Risk", text="Avg Risk")
            all_tree.heading("AllocMethod", text="Allocation Method")

            for col in ["Stratum", "Population", "Sampled", "Coverage", "Avg_Risk", "AllocMethod"]:
                all_tree.column(col, width=100)

            all_scrollbar = ttk.Scrollbar(all_frame, orient="vertical", command=all_tree.yview)
            all_tree.configure(yscrollcommand=all_scrollbar.set)
            all_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            all_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            self.method_coverage_tabs[method_key] = {'missed_tree': missed_tree, 'all_tree': all_tree}

    def create_tab5_widgets(self):
        """Tab 5: Visualizations"""

        control_frame = ttk.LabelFrame(self.tab5, text="Controls", padding="10")
        control_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=5)

        ttk.Button(control_frame, text="Generate Charts", command=self.generate_charts).grid(row=0, column=0, padx=5)

        viz_frame = ttk.LabelFrame(self.tab5, text="Visualizations", padding="10")
        viz_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)

        self.fig, self.axes = plt.subplots(2, 3, figsize=(17, 9))
        self.fig.patch.set_facecolor('#f0f0f0')

        self.canvas = FigureCanvasTkAgg(self.fig, master=viz_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        self.tab5.rowconfigure(1, weight=1)
        self.tab5.columnconfigure(0, weight=1)
        viz_frame.rowconfigure(0, weight=1)
        viz_frame.columnconfigure(0, weight=1)

    # ========== DATA LOADING ==========

    def load_data(self):
        file_path = filedialog.askopenfilename(title="Select Data File", filetypes=[("CSV", "*.csv"), ("Excel", "*.xlsx")])

        if file_path:
            try:
                self.data = pd.read_excel(file_path) if file_path.endswith('.xlsx') else pd.read_csv(file_path)
                if 'exception_id' not in self.data.columns:
                    self.data.insert(0, 'exception_id', range(1, len(self.data) + 1))
                self.update_column_dropdowns()
                self.update_data_preview()
                self.data_label.config(text=f"✓ Loaded {len(self.data):,} records (DYNAMIC POPULATION)")
                messagebox.showinfo("Success", f"Loaded {len(self.data):,} records")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load data: {str(e)}")

    def update_column_dropdowns(self):
        if self.data is None:
            return
        columns = list(self.data.columns)
        self.entity_col_combo['values'] = columns
        self.region_col_combo['values'] = columns
        self.product_col_combo['values'] = columns

    def update_data_preview(self):
        if self.data is None:
            return
        for item in self.tree.get_children():
            self.tree.delete(item)

        display_cols = list(self.data.columns)[:6]
        self.tree["columns"] = display_cols
        self.tree["show"] = "headings"

        for col in display_cols:
            self.tree.heading(col, text=col.replace('_', ' ').title())
            self.tree.column(col, width=100)

        for _, row in self.data.head(50).iterrows():
            values = [str(row.get(col, ''))[:30] for col in display_cols]
            self.tree.insert("", "end", values=values)

    def open_column_selector(self):
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return

        mandatory_cols = [self.entity_col_var.get(), self.region_col_var.get(), self.product_col_var.get()]
        available_cols = [col for col in self.data.columns if col not in mandatory_cols]

        dialog = Toplevel(self.root)
        dialog.title("Select Additional Columns")
        dialog.geometry("400x350")

        ttk.Label(dialog, text="Select columns:").pack(pady=10)

        frame = ttk.Frame(dialog)
        frame.pack(fill='both', expand=True, padx=10, pady=10)

        scrollbar = ttk.Scrollbar(frame)
        scrollbar.pack(side='right', fill='y')

        listbox = Listbox(frame, selectmode=MULTIPLE, yscrollcommand=scrollbar.set)
        listbox.pack(side='left', fill='both', expand=True)
        scrollbar.config(command=listbox.yview)

        for col in available_cols:
            listbox.insert('end', col)

        for i, col in enumerate(available_cols):
            if col in self.selected_additional_columns:
                listbox.selection_set(i)

        def confirm():
            self.selected_additional_columns = [available_cols[i] for i in listbox.curselection()]
            if self.selected_additional_columns:
                self.additional_cols_label.config(text=f"{len(self.selected_additional_columns)} selected", foreground='blue')
            else:
                self.additional_cols_label.config(text="None selected", foreground='gray')
            dialog.destroy()

        ttk.Button(dialog, text="Confirm", command=confirm).pack(pady=10)

    # ========== AUTOMATIC SAMPLE SIZE CALCULATION ==========

    def calculate_sample_size(self, population_size):
        """Calculate optimal sample size using Cochran formula with finite population correction"""
        try:
            confidence = float(self.confidence_var.get().strip('%')) / 100
            margin = float(self.margin_error_var.get().strip('%')) / 100

            # Cochran formula: n = (Z² * p * (1-p)) / e²
            z_value = stats.norm.ppf((1 + confidence) / 2)
            p = 0.5  # Maximum variance assumption

            n = (z_value ** 2 * p * (1 - p)) / (margin ** 2)

            # Apply finite population correction: n_adj = n / (1 + n/N)
            if population_size > 0:
                n_corrected = n / (1 + (n / population_size))
                return max(30, int(np.ceil(n_corrected)))

            return max(30, int(np.ceil(n)))

        except Exception:
            return 300  # Default fallback

    # ========== ENHANCED RISK CALCULATION ==========

    def calculate_risk_scores(self):
        """Calculate risk scores with dynamic population and automatic sample size"""
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return

        try:
            self.root.update()
            entity_col = self.entity_col_var.get()
            region_col = self.region_col_var.get()
            product_col = self.product_col_var.get()

            for col in [entity_col, region_col, product_col]:
                if col not in self.data.columns:
                    messagebox.showerror("Error", f"Column '{col}' not found")
                    return

            # Vectorized weight calculation with NaN handling
            try:
                entity_counts = self.data[entity_col].value_counts(normalize=True)
                region_counts = self.data[region_col].value_counts(normalize=True)
                product_counts = self.data[product_col].value_counts(normalize=True)

                self.data['entity_weight'] = self.data[entity_col].map(entity_counts).fillna(0.5)
                self.data['region_weight'] = self.data[region_col].map(region_counts).fillna(0.5)
                self.data['product_weight'] = self.data[product_col].map(product_counts).fillna(0.5)

                # Composite risk
                self.data['risk_score'] = (
                    self.data['entity_weight'] * 0.33 +
                    self.data['region_weight'] * 0.33 +
                    self.data['product_weight'] * 0.34
                )

                self.data['risk_score'] = np.clip(self.data['risk_score'], 0.01, 1.0)
                self.data['risk_score'] = pd.to_numeric(self.data['risk_score'], errors='coerce').fillna(0.5)

            except Exception as weight_error:
                messagebox.showerror("Error", f"Failed to calculate weights: {str(weight_error)}")
                return

            # Create stratum
            all_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
            try:
                for c in all_cols:
                    if c not in self.data.columns:
                        self.data[c] = 'NA'
                self.data['stratum'] = self.data[all_cols].astype(str).agg('|'.join, axis=1)
            except Exception as stratum_error:
                messagebox.showerror("Error", f"Failed to create stratum: {str(stratum_error)}")
                return

            # Calculate stratum statistics
            try:
                self.calculate_stratum_statistics()
            except Exception as stat_error:
                messagebox.showerror("Error", f"Failed to calculate statistics: {str(stat_error)}")
                return

            # Calculate optimal sample size
            total_pop = len(self.data)
            self.calculated_sample_size = self.calculate_sample_size(total_pop)

            self.display_stratum_results()
            self.risk_calc_label.config(text="✓ Calculated (Ready for sampling)", foreground='green')
            self.calculated_size_label.config(text=f"Sample Size: {self.calculated_sample_size} (Auto-calculated)", foreground='green')
            self.auto_size_label.config(text=f"Sample Size: {self.calculated_sample_size} (Auto-calculated)", foreground='green')

            messagebox.showinfo("Success", f"Risk calculation complete!\nOptimal Sample Size: {self.calculated_sample_size}")

        except Exception as e:
            messagebox.showerror("Error", f"Calculation failed: {str(e)}")

    def calculate_stratum_statistics(self):
        """Calculate stratum statistics with robust NaN handling"""
        try:
            grouped = self.data.groupby('stratum', as_index=False).agg({
                'risk_score': ['mean', 'std', 'count', lambda x: (x > 0.7).sum()]
            })

            grouped.columns = ['stratum', 'avg_risk', 'std_risk', 'population', 'high_risk']

            grouped['std_risk'] = pd.to_numeric(grouped['std_risk'], errors='coerce').fillna(0.1)
            grouped['avg_risk'] = pd.to_numeric(grouped['avg_risk'], errors='coerce').fillna(0.5)
            grouped['population'] = pd.to_numeric(grouped['population'], errors='coerce').astype(int)
            grouped['high_risk'] = pd.to_numeric(grouped['high_risk'], errors='coerce').astype(int)

            total_pop = len(self.data)
            grouped['pop_percent'] = (grouped['population'] / total_pop * 100).round(2)

            grouped['risk_level'] = grouped['avg_risk'].apply(
                lambda x: 'HIGH' if x > 0.7 else ('MEDIUM' if x > 0.4 else 'LOW')
            )

            self.stratum_stats = grouped

        except Exception as e:
            raise Exception(f"Stratum statistics calculation failed: {str(e)}")

    def display_stratum_results(self):
        """Display stratum results"""
        for item in self.stratum_tree.get_children():
            self.stratum_tree.delete(item)

        if self.stratum_stats is None:
            return

        for _, row in self.stratum_stats.head(1000).iterrows():
            try:
                self.stratum_tree.insert("", "end", values=(
                    str(row['stratum'])[:80],
                    int(row['population']),
                    f"{float(row['avg_risk']):.4f}",
                    int(row['high_risk']),
                    row['risk_level'],
                    f"{float(row['pop_percent']):.2f}%",
                    f"{float(row['std_risk']):.4f}"
                ))
            except Exception:
                continue

    # ========== ENHANCED SAMPLING METHODS ==========

    def _seed_for_stratum(self, s):
        """Deterministic seed for a stratum string (32-bit positive int)"""
        try:
            return abs(hash(s)) % (2**31 - 1)
        except Exception:
            return 42

    def generate_samples_enhanced(self):
        """Generate samples using industry-standard methodologies"""
        if self.data is None or 'risk_score' not in self.data.columns:
            messagebox.showerror("Error", "Calculate risk scores first")
            return

        if self.calculated_sample_size is None:
            messagebox.showerror("Error", "Risk calculation not complete")
            return

        try:
            sample_size = self.calculated_sample_size
            self.comparison_results = {}

            total_population = len(self.data)
            target_n = min(sample_size, total_population)

            # METHODOLOGY 1: Simple Random Sampling (SRS) - no per-stratum seed
            if self.method_vars['traditional'].get():
                try:
                    sample = self.data.sample(n=target_n, random_state=None)
                    missed_strata = list(set(self.data['stratum'].unique()) - set(sample['stratum'].unique()))
                    self.comparison_results['traditional'] = {
                        'sample': sample.copy(),
                        'size': len(sample),
                        'high_risk': len(sample[sample['risk_score'] > 0.7]),
                        'avg_risk': float(sample['risk_score'].mean()) if len(sample) > 0 else 0.0,
                        'method_type': 'SRS',
                        'strata_covered': len(sample['stratum'].unique()),
                        'missed_strata': missed_strata
                    }
                except Exception as e:
                    messagebox.showerror("Error in Simple Random", f"Failed: {str(e)}")

            # METHODOLOGY 2: Proportional Stratified
            if self.method_vars['proportional'].get():
                try:
                    samples = []
                    for stratum, group in self.data.groupby('stratum'):
                        stratum_size = len(group)
                        proportion = stratum_size / len(self.data)
                        n_alloc = max(1, int(round(target_n * proportion)))

                        if self.seed_per_stratum_var.get():
                            seed = self._seed_for_stratum(stratum)
                            sample_subset = group.sample(n=min(n_alloc, len(group)), random_state=seed)
                        else:
                            sample_subset = group.sample(n=min(n_alloc, len(group)), random_state=42)

                        samples.append(sample_subset)

                    sample = pd.concat(samples, ignore_index=True).head(target_n)
                    missed_strata = list(set(self.data['stratum'].unique()) - set(sample['stratum'].unique()))
                    self.comparison_results['proportional'] = {
                        'sample': sample.copy(),
                        'size': len(sample),
                        'high_risk': len(sample[sample['risk_score'] > 0.7]),
                        'avg_risk': float(sample['risk_score'].mean()) if len(sample) > 0 else 0.0,
                        'method_type': 'Proportional',
                        'strata_covered': len(sample['stratum'].unique()),
                        'missed_strata': missed_strata
                    }
                except Exception as e:
                    messagebox.showerror("Error in Proportional", f"Failed: {str(e)}")

            # METHODOLOGY 3: Neyman Allocation
            if self.method_vars['neyman'].get():
                try:
                    samples = []
                    total_weight = 0.0

                    for stratum, group in self.data.groupby('stratum'):
                        stratum_size = len(group)
                        stratum_std = float(group['risk_score'].std() or 0.1)
                        allocation_weight = stratum_size * stratum_std
                        total_weight += allocation_weight

                    strata_groups = list(self.data.groupby('stratum'))
                    if total_weight <= 0:
                        total_weight = 1.0 * len(strata_groups)

                    for stratum, group in strata_groups:
                        stratum_size = len(group)
                        stratum_std = float(group['risk_score'].std() or 0.1)
                        allocation_weight = stratum_size * stratum_std

                        n_alloc = max(1, int(round(target_n * (allocation_weight / total_weight)))) if total_weight > 0 else max(1, int(round(target_n / len(strata_groups))))

                        if self.seed_per_stratum_var.get():
                            seed = self._seed_for_stratum(stratum)
                            sample_subset = group.sample(n=min(n_alloc, len(group)), random_state=seed)
                        else:
                            sample_subset = group.sample(n=min(n_alloc, len(group)), random_state=42)

                        samples.append(sample_subset)

                    sample = pd.concat(samples, ignore_index=True).head(target_n)
                    missed_strata = list(set(self.data['stratum'].unique()) - set(sample['stratum'].unique()))
                    self.comparison_results['neyman'] = {
                        'sample': sample.copy(),
                        'size': len(sample),
                        'high_risk': len(sample[sample['risk_score'] > 0.7]),
                        'avg_risk': float(sample['risk_score'].mean()) if len(sample) > 0 else 0.0,
                        'method_type': 'Neyman',
                        'strata_covered': len(sample['stratum'].unique()),
                        'missed_strata': missed_strata
                    }
                except Exception as e:
                    messagebox.showerror("Error in Neyman", f"Failed: {str(e)}")

            if not self.comparison_results:
                messagebox.showerror("Error", "No methods selected or all methods failed")
                return

            self.update_results_display()
            self.update_coverage_display_enhanced()
            messagebox.showinfo("Success", f"Samples generated!\nSample Size (target for each method): {target_n}")

        except Exception as e:
            messagebox.showerror("Error", f"Sample generation failed: {str(e)}")

    def update_results_display(self):
        """Display results with error handling"""
        for item in self.summary_tree.get_children():
            self.summary_tree.delete(item)

        method_display = {
            'traditional': 'Simple Random',
            'proportional': 'Proportional',
            'neyman': 'Neyman'
        }

        for method, data in self.comparison_results.items():
            try:
                display_name = method_display.get(method, method)
                self.summary_tree.insert("", "end", text=display_name,
                                        values=(data['size'], data['high_risk'], f"{data['avg_risk']:.4f}",
                                                data['strata_covered'], data['method_type']))
            except Exception:
                continue

    def update_coverage_display_enhanced(self):
        """Display coverage analysis with error handling"""
        for method_key, result in self.comparison_results.items():
            sample = result['sample']
            all_strata = list(self.data['stratum'].unique())
            sample_strata = set(sample['stratum'].unique())
            missed = set(all_strata) - sample_strata

            tabs = self.method_coverage_tabs.get(method_key)
            if not tabs:
                continue

            # Missed strata
            for item in tabs['missed_tree'].get_children():
                tabs['missed_tree'].delete(item)

            for idx, stratum in enumerate(sorted(list(missed))[:100]):
                try:
                    stratum_data = self.data[self.data['stratum'] == stratum]
                    tabs['missed_tree'].insert("", "end", text=str(idx + 1),
                                              values=(stratum, len(stratum_data), f"{stratum_data['risk_score'].mean():.4f}"))
                except Exception:
                    continue

            # All strata
            for item in tabs['all_tree'].get_children():
                tabs['all_tree'].delete(item)

            for idx, stratum in enumerate(sorted(all_strata)[:100]):
                try:
                    pop_data = self.data[self.data['stratum'] == stratum]
                    sample_data = sample[sample['stratum'] == stratum]
                    coverage = len(sample_data) / len(pop_data) * 100 if len(pop_data) > 0 else 0

                    alloc_method = 'Allocated' if len(sample_data) > 0 else 'Missed'

                    tabs['all_tree'].insert("", "end", text=str(idx + 1),
                                           values=(stratum, len(pop_data), len(sample_data),
                                                   f"{coverage:.1f}%", f"{pop_data['risk_score'].mean():.4f}", alloc_method))
                except Exception:
                    continue

    # ========== EXPORTS & RUN SUMMARY ==========

    def _timestamp(self):
        return datetime.now().strftime("%Y%m%d_%H%M%S")

    def _write_run_summary(self, summary_file, exported_files, export_type='covered'):
        """Write run summary with formulas, assumptions, and exported filenames"""
        try:
            with open(summary_file, 'w') as f:
                f.write("=" * 80 + "\n")
                f.write("OMRC AUDIT SAMPLING TOOL v8.9 - RUN SUMMARY\n")
                f.write("=" * 80 + "\n\n")
                
                f.write(f"Execution Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Export Type: {export_type.upper()}\n\n")
                
                # Parameters
                f.write("SAMPLING PARAMETERS\n")
                f.write("-" * 80 + "\n")
                f.write(f"Confidence Level: {self.confidence_var.get()}\n")
                f.write(f"Margin of Error: {self.margin_error_var.get()}\n")
                f.write(f"Calculated Sample Size: {self.calculated_sample_size}\n")
                f.write(f"Population Size: {len(self.data) if self.data is not None else 'N/A'}\n")
                f.write(f"Seed per Stratum: {self.seed_per_stratum_var.get()}\n\n")
                
                # Formulas
                f.write("STATISTICAL FORMULAS USED\n")
                f.write("-" * 80 + "\n")
                f.write("1. Cochran Formula: n = (Z² × p × (1-p)) / e²\n")
                f.write("   - Z: Critical value for confidence level\n")
                f.write("   - p: Estimated proportion (0.5 for maximum variance)\n")
                f.write("   - e: Margin of error\n\n")
                f.write("2. Finite Population Correction: n_adj = n / (1 + n/N)\n")
                f.write("   - Applied when N < 5n\n\n")
                f.write("3. Proportional Allocation: n_h = n × (N_h / N)\n")
                f.write("   - Allocates samples proportional to stratum size\n\n")
                f.write("4. Neyman Allocation: n_h = n × (N_h × S_h) / Σ(N_h × S_h)\n")
                f.write("   - Allocates samples based on stratum size and variability\n\n")
                
                # Methods
                f.write("SAMPLING METHODS APPLIED\n")
                f.write("-" * 80 + "\n")
                for method, enabled in self.method_vars.items():
                    status = "✓ Applied" if enabled.get() else "✗ Not Applied"
                    f.write(f"- {method}: {status}\n")
                f.write("\n")
                
                # Results
                f.write("SAMPLING RESULTS\n")
                f.write("-" * 80 + "\n")
                for method, result in self.comparison_results.items():
                    f.write(f"\n{method.upper()}:\n")
                    f.write(f"  Sample Size: {result['size']}\n")
                    f.write(f"  High Risk Count: {result['high_risk']}\n")
                    f.write(f"  Average Risk Score: {result['avg_risk']:.4f}\n")
                    f.write(f"  Strata Covered: {result['strata_covered']}\n")
                    f.write(f"  Missed Strata: {len(result['missed_strata'])}\n")
                f.write("\n")
                
                # Exported Files
                f.write("EXPORTED FILES\n")
                f.write("-" * 80 + "\n")
                for filepath in exported_files:
                    f.write(f"- {os.path.basename(filepath)}\n")
                f.write("\n")
                
                f.write("=" * 80 + "\n")
                f.write("END OF RUN SUMMARY\n")
                f.write("=" * 80 + "\n")
        except Exception as e:
            print(f"Warning: Could not write run summary: {str(e)}")

    def export_samples_covered(self):
        """Export the sampled records (covered) for each method to CSV"""
        if not self.comparison_results:
            messagebox.showerror("Error", "Generate samples first")
            return

        exported_files = []
        try:
            ts = self._timestamp()
            for method, data in self.comparison_results.items():
                try:
                    filename = os.path.join(self.results_dir, f"sample_{method}_{ts}.csv")
                    data['sample'].to_csv(filename, index=False)
                    exported_files.append(filename)
                except Exception as e:
                    messagebox.showwarning("Export Warning", f"Could not export {method} sample: {str(e)}")
            
            summary_file = os.path.join(self.results_dir, f"run_summary_{ts}.txt")
            self._write_run_summary(summary_file, exported_files, export_type='covered')
            messagebox.showinfo("Success", f"Covered samples exported to {self.results_dir}\nRun summary: {os.path.basename(summary_file)}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")

    def export_missed_strata_all(self):
        """Export missed strata per method. If none missed, export empty CSV with headers."""
        if not self.comparison_results:
            messagebox.showerror("Error", "Generate samples first")
            return

        exported_files = []
        try:
            ts = self._timestamp()
            for method, data in self.comparison_results.items():
                try:
                    missed = data.get('missed_strata', [])
                    filename = os.path.join(self.results_dir, f"missed_strata_{method}_{ts}.csv")

                    if missed:
                        missed_df = self.data[self.data['stratum'].isin(missed)].copy()
                        missed_df.to_csv(filename, index=False)
                    else:
                        pd.DataFrame(columns=self.data.columns).to_csv(filename, index=False)

                    exported_files.append(filename)
                except Exception as e:
                    messagebox.showwarning("Export Warning", f"Could not export missed strata for {method}: {str(e)}")

            summary_file = os.path.join(self.results_dir, f"run_summary_{ts}.txt")
            self._write_run_summary(summary_file, exported_files, export_type='missed')
            messagebox.showinfo("Success", f"Missed strata files exported to {self.results_dir}\nRun summary: {os.path.basename(summary_file)}")
        except Exception as e:
            messagebox.showerror("Error", f"Export missed strata failed: {str(e)}")

    def export_out_of_scope(self):
        """Export records missed by ALL methods (out-of-scope)"""
        if not self.comparison_results:
            messagebox.showerror("Error", "Generate samples first")
            return

        try:
            all_missed_across_methods = None
            for method, result in self.comparison_results.items():
                method_missed_set = set(result['missed_strata'])
                if all_missed_across_methods is None:
                    all_missed_across_methods = method_missed_set
                else:
                    all_missed_across_methods = all_missed_across_methods.intersection(method_missed_set)

            if not all_missed_across_methods:
                messagebox.showinfo("Info", "No records were missed by ALL methods (full coverage achieved)")
                return

            ts = self._timestamp()
            filename = os.path.join(self.results_dir, f"out_of_scope_{ts}.csv")
            
            out_of_scope_df = self.data[self.data['stratum'].isin(list(all_missed_across_methods))]
            out_of_scope_df.to_csv(filename, index=False)

            messagebox.showinfo("Success", f"Out-of-scope records exported to {filename}")
        except Exception as e:
            messagebox.showerror("Error", f"Export out-of-scope failed: {str(e)}")

    def generate_charts(self):
        """Generate visualization charts"""
        if not self.comparison_results or self.stratum_stats is None:
            messagebox.showerror("Error", "Generate samples first")
            return

        try:
            for ax in self.axes.flat:
                ax.clear()

            # Chart 1: Sample Size Comparison
            methods = list(self.comparison_results.keys())
            sizes = [self.comparison_results[m]['size'] for m in methods]
            self.axes[0, 0].bar(methods, sizes, color='steelblue')
            self.axes[0, 0].set_title("Sample Size by Method", fontweight='bold')
            self.axes[0, 0].set_ylabel("Count")

            # Chart 2: High Risk Comparison
            high_risks = [self.comparison_results[m]['high_risk'] for m in methods]
            self.axes[0, 1].bar(methods, high_risks, color='coral')
            self.axes[0, 1].set_title("High Risk Items by Method", fontweight='bold')
            self.axes[0, 1].set_ylabel("Count")

            # Chart 3: Average Risk Score
            avg_risks = [self.comparison_results[m]['avg_risk'] for m in methods]
            self.axes[0, 2].bar(methods, avg_risks, color='lightgreen')
            self.axes[0, 2].set_title("Average Risk Score by Method", fontweight='bold')
            self.axes[0, 2].set_ylabel("Average Risk")

            # Chart 4: Strata Coverage
            strata_covered = [self.comparison_results[m]['strata_covered'] for m in methods]
            self.axes[1, 0].bar(methods, strata_covered, color='mediumpurple')
            self.axes[1, 0].set_title("Strata Covered by Method", fontweight='bold')
            self.axes[1, 0].set_ylabel("Count")

            # Chart 5: Risk Distribution by Stratum
            risk_levels = self.stratum_stats['risk_level'].value_counts()
            self.axes[1, 1].pie(risk_levels, labels=risk_levels.index, autopct='%1.1f%%')
            self.axes[1, 1].set_title("Risk Distribution of Strata", fontweight='bold')

            # Chart 6: Population vs Sample
            total_pop = len(self.data)
            sample_sizes = [self.comparison_results[m]['size'] for m in methods]
            x_pos = np.arange(len(methods))
            self.axes[1, 2].bar(x_pos - 0.2, [total_pop] * len(methods), 0.4, label='Population', color='lightblue')
            self.axes[1, 2].bar(x_pos + 0.2, sample_sizes, 0.4, label='Sample', color='darkblue')
            self.axes[1, 2].set_xticks(x_pos)
            self.axes[1, 2].set_xticklabels(methods)
            self.axes[1, 2].set_title("Population vs Sample Size", fontweight='bold')
            self.axes[1, 2].legend()

            self.fig.tight_layout()
            self.canvas.draw()
            messagebox.showinfo("Success", "Charts generated successfully")

        except Exception as e:
            messagebox.showerror("Error", f"Chart generation failed: {str(e)}")


def main():
    root = tk.Tk()
    out_dir = os.path.expanduser("~")
    app = OMRCRiskBasedSamplingTool(root, out_dir)
    root.mainloop()


if __name__ == "__main__":
    main()
