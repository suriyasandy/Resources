#!/usr/bin/env python3
"""
OMRC Audit Sampling Tool – v10.1
Dataset-driven column selection | Fully scrollable UI | Audit-ready
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import numpy as np
import os
from datetime import datetime


class AuditSamplingApp:

    def __init__(self, root):
        self.root = root
        self.root.title("Audit Sampling Tool – Rule-Based Stratified")
        self.root.geometry("1850x1050")

        self.data = None
        self.optional_cols = []
        self.stratum_stats = None
        self.sample_df = None

        self.build_ui()

    # ================= UI =================

    def build_ui(self):
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill="both", expand=True)

        self.tab1 = ttk.Frame(notebook)
        self.tab2 = ttk.Frame(notebook)
        self.tab3 = ttk.Frame(notebook)
        self.tab4 = ttk.Frame(notebook)

        notebook.add(self.tab1, text="1. Data & Columns")
        notebook.add(self.tab2, text="2. Stratum & Risk Stats")
        notebook.add(self.tab3, text="3. Sampling Results")
        notebook.add(self.tab4, text="4. Documentation & Export")

        self.build_tab1()
        self.build_tab2()
        self.build_tab3()
        self.build_tab4()

    # ================= COMMON SCROLLABLE TREE =================

    def create_scrollable_tree(self, parent, columns):
        frame = ttk.Frame(parent)
        frame.pack(fill="both", expand=True)

        tree = ttk.Treeview(frame, columns=columns, show="headings")
        vsb = ttk.Scrollbar(frame, orient="vertical", command=tree.yview)
        hsb = ttk.Scrollbar(frame, orient="horizontal", command=tree.xview)
        tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")
        hsb.grid(row=1, column=0, sticky="ew")

        frame.rowconfigure(0, weight=1)
        frame.columnconfigure(0, weight=1)

        for c in columns:
            tree.heading(c, text=c)
            tree.column(c, width=220)

        return tree

    # ================= TAB 1 =================

    def build_tab1(self):
        top = ttk.LabelFrame(self.tab1, text="Load Dataset", padding=10)
        top.pack(fill="x")

        ttk.Button(top, text="Load Data", command=self.load_data).pack(side="left")
        self.data_label = ttk.Label(top, text="No data loaded", foreground="blue")
        self.data_label.pack(side="left", padx=10)

        cols = ttk.LabelFrame(self.tab1, text="Mandatory & Optional Columns", padding=10)
        cols.pack(fill="x", pady=5)

        ttk.Label(cols, text="Region Column").grid(row=0, column=0)
        self.region_col = tk.StringVar()
        self.region_combo = ttk.Combobox(cols, textvariable=self.region_col, width=25)
        self.region_combo.grid(row=0, column=1)

        ttk.Label(cols, text="Product Column").grid(row=0, column=2, padx=10)
        self.product_col = tk.StringVar()
        self.product_combo = ttk.Combobox(cols, textvariable=self.product_col, width=25)
        self.product_combo.grid(row=0, column=3)

        ttk.Button(cols, text="Select Optional Columns",
                   command=self.select_optional_columns).grid(row=0, column=4, padx=20)

        preview = ttk.LabelFrame(self.tab1, text="Data Preview (Scrollable)", padding=10)
        preview.pack(fill="both", expand=True)

        self.preview_tree = self.create_scrollable_tree(preview, [])

    # ================= TAB 2 =================

    def build_tab2(self):
        ttk.Button(self.tab2, text="Calculate Stratum & Risk Statistics",
                   command=self.calculate_stratum_stats).pack(pady=10)

        self.stats_tree = self.create_scrollable_tree(
            self.tab2,
            ["Stratum", "Population", "RiskScore", "Percent"]
        )

    # ================= TAB 3 =================

    def build_tab3(self):
        ttk.Button(self.tab3, text="Generate Sample",
                   command=self.generate_sample).pack(pady=10)

        self.sample_tree = self.create_scrollable_tree(
            self.tab3,
            ["Metric", "Value"]
        )

        self.unsampled_tree = self.create_scrollable_tree(
            self.tab3,
            ["Stratum", "Population"]
        )

    # ================= TAB 4 =================

    def build_tab4(self):
        self.doc_text = tk.Text(self.tab4, wrap="word", font=("Arial", 10))
        self.doc_text.pack(fill="both", expand=True)

        export = ttk.Frame(self.tab4)
        export.pack(fill="x")

        ttk.Button(export, text="Export Sampled Data", command=self.export_sample).pack(side="left", padx=5)
        ttk.Button(export, text="Export Unsampled Strata", command=self.export_unsampled).pack(side="left", padx=5)
        ttk.Button(export, text="Export Stratum Statistics", command=self.export_stats).pack(side="left", padx=5)
        ttk.Button(export, text="Export Documentation", command=self.export_doc).pack(side="left", padx=5)

    # ================= CORE LOGIC =================

    def load_data(self):
        path = filedialog.askopenfilename(filetypes=[("CSV", "*.csv"), ("Excel", "*.xlsx")])
        if not path:
            return

        self.data = pd.read_excel(path) if path.endswith(".xlsx") else pd.read_csv(path)
        self.data_label.config(text=f"Loaded {len(self.data)} records")

        cols = list(self.data.columns)
        self.region_combo["values"] = cols
        self.product_combo["values"] = cols

        self.preview_tree.destroy()
        self.preview_tree = self.create_scrollable_tree(
            self.tab1,
            cols[:8]
        )

        for _, r in self.data.head(25).iterrows():
            self.preview_tree.insert("", "end", values=list(r[cols[:8]]))

    def select_optional_columns(self):
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return

        win = tk.Toplevel(self.root)
        win.title("Select Optional Columns")

        lb = tk.Listbox(win, selectmode="multiple", width=40)
        lb.pack(fill="both", expand=True)

        for c in self.data.columns:
            lb.insert("end", c)

        def confirm():
            self.optional_cols = [lb.get(i) for i in lb.curselection()]
            win.destroy()

        ttk.Button(win, text="Confirm", command=confirm).pack(pady=5)

    def calculate_stratum_stats(self):
        r = self.region_col.get()
        p = self.product_col.get()

        if not r or not p:
            messagebox.showerror("Error", "Select Region and Product columns")
            return

        cols = [r, p] + self.optional_cols
        self.data["stratum"] = self.data[cols].astype(str).agg("|".join, axis=1)

        stats = self.data.groupby("stratum").size().reset_index(name="population")
        total = len(self.data)
        stats["risk_score"] = stats["population"] / total
        stats["percent"] = stats["risk_score"] * 100

        self.stratum_stats = stats

        self.stats_tree.delete(*self.stats_tree.get_children())
        for _, s in stats.iterrows():
            self.stats_tree.insert(
                "", "end",
                values=(s["stratum"], s["population"],
                        f"{s['risk_score']:.4f}",
                        f"{s['percent']:.2f}%")
            )

    def generate_sample(self):
        min_n, max_n = 300, 350
        total = len(self.data)
        target_n = min(max_n, max(min_n, int(total * 0.10)))

        base = []
        for s, g in self.data.groupby("stratum"):
            base.append(g.sample(1))

        base_df = pd.concat(base)
        remaining = target_n - len(base_df)

        pool = self.data.drop(base_df.index)
        weights = pool["stratum"].map(
            self.stratum_stats.set_index("stratum")["risk_score"]
        )

        extra = pool.sample(n=min(remaining, len(pool)), weights=weights)
        self.sample_df = pd.concat([base_df, extra])

        self.sample_tree.delete(*self.sample_tree.get_children())
        self.sample_tree.insert("", "end", values=("Total Population", total))
        self.sample_tree.insert("", "end", values=("Total Strata", self.data["stratum"].nunique()))
        self.sample_tree.insert("", "end", values=("Final Sample Size", len(self.sample_df)))

        self.unsampled_tree.delete(*self.unsampled_tree.get_children())
        missed = set(self.data["stratum"]) - set(self.sample_df["stratum"])
        for m in missed:
            pop = len(self.data[self.data["stratum"] == m])
            self.unsampled_tree.insert("", "end", values=(m, pop))

        self.generate_documentation(target_n)

    # ================= EXPORTS =================

    def export_sample(self):
        self.sample_df.to_csv("sampled_data.csv", index=False)

    def export_unsampled(self):
        missed = set(self.data["stratum"]) - set(self.sample_df["stratum"])
        self.data[self.data["stratum"].isin(missed)].to_csv("unsampled_strata.csv", index=False)

    def export_stats(self):
        self.stratum_stats.to_csv("stratum_statistics.csv", index=False)

    def export_doc(self):
        with open("sampling_documentation.txt", "w") as f:
            f.write(self.doc_text.get("1.0", tk.END))

    # ================= DOCUMENTATION =================

    def generate_documentation(self, target_n):
        self.doc_text.delete("1.0", tk.END)
        self.doc_text.insert(tk.END, f"""
AUDIT SAMPLING DOCUMENTATION

1. STRATUM DEFINITION
Strata were defined using user-selected columns:
Region + Product + optional attributes.

2. SAMPLE SIZE RULE
Lower bound: 300
Upper bound: 350
Target based on population: {target_n}
Final sample size used: {len(self.sample_df)}

3. STRATUM COVERAGE
At least one record was selected from every stratum.

4. RISK-BASED FILL
Remaining samples were selected proportionally based on
stratum population share (risk score).

5. AUDIT ALIGNMENT
This approach aligns with ISA 530 and internal audit standards.
""")


def main():
    root = tk.Tk()
    AuditSamplingApp(root)
    root.mainloop()


if __name__ == "__main__":
    main()
