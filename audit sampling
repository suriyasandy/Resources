#!/usr/bin/env python3
"""
OMRC Audit Sampling Tool v9.1
AUDIT-READY | HYBRID STRATIFIED SAMPLING | FULL TRACEABILITY
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import numpy as np
from scipy import stats
import os
from datetime import datetime
import warnings

warnings.filterwarnings("ignore")


class OMRCRiskBasedSamplingTool:

    def __init__(self, root, out_dir):
        self.root = root
        self.root.title("OMRC Audit Sampling Tool v9.1")
        self.root.geometry("1700x1000")

        self.data = None
        self.calculated_sample_size = None
        self.comparison_results = {}

        self.results_dir = os.path.join(out_dir, "OMRC_Results")
        os.makedirs(self.results_dir, exist_ok=True)

        self.build_ui()

    # ================= UI =================

    def build_ui(self):
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill="both", expand=True)

        self.tab1 = ttk.Frame(notebook)
        self.tab2 = ttk.Frame(notebook)
        self.tab3 = ttk.Frame(notebook)
        self.tab4 = ttk.Frame(notebook)

        notebook.add(self.tab1, text="1. Data & Configuration")
        notebook.add(self.tab2, text="2. Risk Calculation")
        notebook.add(self.tab3, text="3. Sampling & Results")
        notebook.add(self.tab4, text="4. Coverage & Audit Explanation")

        self.build_tab1()
        self.build_tab2()
        self.build_tab3()
        self.build_tab4()

    # ================= TAB 1 =================

    def build_tab1(self):
        frame = ttk.LabelFrame(self.tab1, text="Load Data", padding=10)
        frame.pack(fill="x")

        ttk.Button(frame, text="Load Data", command=self.load_data).pack(side="left")
        self.data_label = ttk.Label(frame, text="No data loaded", foreground="blue")
        self.data_label.pack(side="left", padx=10)

        mandatory = ttk.LabelFrame(self.tab1, text="Mandatory Columns", padding=10)
        mandatory.pack(fill="x", pady=5)

        ttk.Label(mandatory, text="Region Column").grid(row=0, column=0)
        self.region_col = tk.StringVar(value="region")
        ttk.Combobox(mandatory, textvariable=self.region_col, width=25).grid(row=0, column=1)

        ttk.Label(mandatory, text="Product Column").grid(row=0, column=2, padx=10)
        self.product_col = tk.StringVar(value="product")
        ttk.Combobox(mandatory, textvariable=self.product_col, width=25).grid(row=0, column=3)

        preview = ttk.LabelFrame(self.tab1, text="Data Preview", padding=10)
        preview.pack(fill="both", expand=True)

        self.preview_tree = ttk.Treeview(preview, height=12)
        self.preview_tree.pack(fill="both", expand=True)

    # ================= TAB 2 =================

    def build_tab2(self):
        frame = ttk.Frame(self.tab2)
        frame.pack(fill="x", pady=5)

        ttk.Button(frame, text="Calculate Risk", command=self.calculate_risk).pack(side="left")
        self.sample_label = ttk.Label(frame, text="Sample Size: --", foreground="green")
        self.sample_label.pack(side="left", padx=20)

        self.risk_tree = ttk.Treeview(
            self.tab2,
            columns=("Stratum", "Population", "AvgRisk"),
            show="headings"
        )
        self.risk_tree.pack(fill="both", expand=True)

        for c in ["Stratum", "Population", "AvgRisk"]:
            self.risk_tree.heading(c, text=c)
            self.risk_tree.column(c, width=250)

    # ================= TAB 3 =================

    def build_tab3(self):
        methods = ttk.LabelFrame(self.tab3, text="Sampling Methods", padding=10)
        methods.pack(fill="x")

        self.use_srs = tk.BooleanVar(value=True)
        self.use_stratified = tk.BooleanVar(value=True)

        ttk.Checkbutton(methods, text="Simple Random Sampling", variable=self.use_srs).pack(anchor="w")
        ttk.Checkbutton(methods, text="Hybrid Stratified (Risk-Based)", variable=self.use_stratified).pack(anchor="w")

        ttk.Button(methods, text="Generate Samples", command=self.generate_samples).pack(pady=10)

        self.sample_tree = ttk.Treeview(
            self.tab3,
            columns=("Method", "SampleSize", "HighRisk", "StrataCovered"),
            show="headings",
            height=8
        )
        self.sample_tree.pack(fill="x")

        for c in ["Method", "SampleSize", "HighRisk", "StrataCovered"]:
            self.sample_tree.heading(c, text=c)
            self.sample_tree.column(c, width=200)

    # ================= TAB 4 =================

    def build_tab4(self):
        split = ttk.PanedWindow(self.tab4, orient="horizontal")
        split.pack(fill="both", expand=True)

        left = ttk.LabelFrame(split, text="Missed Strata", padding=10)
        right = ttk.LabelFrame(split, text="Audit Explanation", padding=10)
        split.add(left, weight=1)
        split.add(right, weight=1)

        self.coverage_tree = ttk.Treeview(
            left,
            columns=("Stratum", "Population", "AvgRisk"),
            show="headings"
        )
        self.coverage_tree.pack(fill="both", expand=True)

        for c in ["Stratum", "Population", "AvgRisk"]:
            self.coverage_tree.heading(c, text=c)
            self.coverage_tree.column(c, width=220)

        self.audit_text = tk.Text(right, wrap="word", font=("Arial", 10))
        self.audit_text.pack(fill="both", expand=True)

    # ================= LOGIC =================

    def load_data(self):
        path = filedialog.askopenfilename(filetypes=[("CSV", "*.csv"), ("Excel", "*.xlsx")])
        if not path:
            return

        self.data = pd.read_excel(path) if path.endswith(".xlsx") else pd.read_csv(path)
        if "exception_id" not in self.data.columns:
            self.data.insert(0, "exception_id", range(1, len(self.data) + 1))

        self.data_label.config(text=f"Loaded {len(self.data)} records")
        self.show_preview()

    def show_preview(self):
        self.preview_tree.delete(*self.preview_tree.get_children())
        cols = list(self.data.columns[:6])
        self.preview_tree["columns"] = cols
        self.preview_tree["show"] = "headings"

        for c in cols:
            self.preview_tree.heading(c, text=c)
            self.preview_tree.column(c, width=120)

        for _, r in self.data.head(25).iterrows():
            self.preview_tree.insert("", "end", values=list(r[cols]))

    def calculate_sample_size(self, N):
        z = stats.norm.ppf(0.975)
        p, e = 0.5, 0.05
        n = (z**2 * p * (1-p)) / e**2
        return max(30, int(n / (1 + n / N)))

    def calculate_risk(self):
        r, p = self.region_col.get(), self.product_col.get()

        self.data["risk_score"] = (
            self.data[r].map(self.data[r].value_counts(normalize=True)).fillna(0.5) * 0.5 +
            self.data[p].map(self.data[p].value_counts(normalize=True)).fillna(0.5) * 0.5
        )

        self.data["stratum"] = self.data[[r, p]].astype(str).agg("|".join, axis=1)
        self.calculated_sample_size = self.calculate_sample_size(len(self.data))
        self.sample_label.config(text=f"Sample Size: {self.calculated_sample_size}")

        self.show_risk_summary()

    def show_risk_summary(self):
        self.risk_tree.delete(*self.risk_tree.get_children())
        g = self.data.groupby("stratum").agg(
            population=("exception_id", "count"),
            avg_risk=("risk_score", "mean")
        ).reset_index()

        for _, r in g.iterrows():
            self.risk_tree.insert("", "end", values=(r["stratum"], r["population"], f"{r['avg_risk']:.4f}"))

    def generate_samples(self):
        self.sample_tree.delete(*self.sample_tree.get_children())
        self.coverage_tree.delete(*self.coverage_tree.get_children())

        strata_groups = list(self.data.groupby("stratum"))
        base_samples = [g.sample(1) for _, g in strata_groups]
        base_df = pd.concat(base_samples)

        remaining = max(0, self.calculated_sample_size - len(base_df))
        pool = self.data.drop(base_df.index)

        if remaining > 0:
            extra = pool.sample(
                n=min(remaining, len(pool)),
                weights=pool["risk_score"]
            )
            final_sample = pd.concat([base_df, extra])
        else:
            final_sample = base_df

        self.comparison_results["Hybrid Stratified"] = final_sample

        self.sample_tree.insert(
            "", "end",
            values=(
                "Hybrid Stratified",
                len(final_sample),
                (final_sample["risk_score"] > 0.7).sum(),
                final_sample["stratum"].nunique()
            )
        )

        self.show_coverage(final_sample)
        self.show_audit_explanation(final_sample)

    def show_coverage(self, sample):
        all_s = set(self.data["stratum"])
        covered = set(sample["stratum"])
        missed = all_s - covered

        for s in missed:
            pop = len(self.data[self.data["stratum"] == s])
            avg = self.data[self.data["stratum"] == s]["risk_score"].mean()
            self.coverage_tree.insert("", "end", values=(s, pop, f"{avg:.4f}"))

    def show_audit_explanation(self, sample):
        self.audit_text.delete("1.0", tk.END)
        self.audit_text.insert(tk.END, f"""
AUDIT EXPLANATION â€“ HYBRID STRATIFIED SAMPLING

1. WHY ONE SAMPLE PER STRATUM?
Each stratum (Region + Product) represents a distinct operational risk segment.
Audit standards require representation from all material segments.
Therefore, at least ONE record per stratum is mandatorily selected.

2. WHY SAMPLE SIZE CAN EXCEED TARGET?
If number of strata > statistically calculated sample size,
the final sample is expanded to maintain minimum stratum coverage.
This is an intentional and auditable design choice.

3. HOW ARE REMAINING SAMPLES SELECTED?
After minimum coverage:
Remaining samples are selected using risk-score-weighted probability
across the entire population.
This prioritizes high-frequency and high-risk occurrences.

4. COMPLIANCE ALIGNMENT
- ISA 530 (Audit Sampling)
- AICPA Audit Guide
- Model is deterministic, explainable, and reproducible.

FINAL SAMPLE SIZE: {len(sample)}
TOTAL STRATA: {sample["stratum"].nunique()}
""")

def main():
    root = tk.Tk()
    app = OMRCRiskBasedSamplingTool(root, os.path.expanduser("~"))
    root.mainloop()

if __name__ == "__main__":
    main()
