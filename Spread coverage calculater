def internal_spread_coverage(df, sampled, spread_col):
    """
    Builds coverage statistics of Internal Spread values within each stratum.
    """

    coverage_rows = []

    for stratum, full_grp in df.groupby("_STRATUM_"):
        sampled_grp = sampled[sampled["_STRATUM_"] == stratum]

        total_unique = set(full_grp[spread_col].dropna().unique())
        sampled_unique = set(sampled_grp[spread_col].dropna().unique())

        unsampled_unique = total_unique - sampled_unique

        coverage_pct = (
            len(sampled_unique) / len(total_unique) * 100
            if len(total_unique) > 0 else 0
        )

        coverage_rows.append({
            "Stratum": stratum,
            "Total_Unique_Values": len(total_unique),
            "Sampled_Unique_Values": len(sampled_unique),
            "Unsampled_Unique_Values": len(unsampled_unique),
            "Coverage_%": round(coverage_pct, 2)
        })

    return pd.DataFrame(coverage_rows)


#inside run sampling 
if spread:
    self.spread_coverage = internal_spread_coverage(df, self.sampled, spread)
else:
    self.spread_coverage = None

#modufy display resukts 
if self.spread_coverage is not None:
    top = tk.Toplevel(self.root)
    top.title("Internal Spread Coverage")

    tree = ttk.Treeview(top)
    tree.pack(fill="both", expand=True)

    tree["columns"] = list(self.spread_coverage.columns)
    tree["show"] = "headings"

    for c in self.spread_coverage.columns:
        tree.heading(c, text=c)
        tree.column(c, width=160)

    for _, row in self.spread_coverage.iterrows():
        tree.insert("", "end", values=list(row))

#add export button
ttk.Button(self.tab_export,
           text="Export Internal Spread Coverage",
           command=self.export_spread).pack(side="left", padx=5)

def export_spread(self):
    if self.spread_coverage is not None:
        self.spread_coverage.to_excel(f"{EXPORT_DIR}/internal_spread_coverage.xlsx",
index=False)


#insidebuil data tab
ttk.Label(top, text="Allocation Mode").pack(side="left", padx=5)

self.alloc_mode = ttk.Combobox(
    top,
    width=22,
    state="readonly",
    values=["Balanced (QA)", "Proportional (Statistical)"]
)
self.alloc_mode.pack(side="left")
self.alloc_mode.set("Balanced (QA)")

#rrplace allocate sample 
def allocate_samples(stats, total_records, mode):
    """
    mode:
        'Balanced (QA)'              → √N allocation
        'Proportional (Statistical)' → N allocation
    """

    target = min(MAX_SAMPLE, max(MIN_SAMPLE, int(total_records * 0.10)))
    stats = stats.copy()

    # --- Mandatory 1 per stratum ---
    stats["base"] = 1
    remaining = target - len(stats)

    if remaining <= 0:
        stats["final_alloc"] = 1
        return stats, target

    if mode == "Balanced (QA)":
        # √N allocation
        weights = np.sqrt(stats["population"])

    else:
        # Original proportional allocation
        weights = stats["population"]

    weights = weights / weights.sum()
    stats["extra"] = np.floor(weights * remaining).astype(int)

    drift = remaining - stats["extra"].sum()
    if drift > 0:
        stats.iloc[:drift, stats.columns.get_loc("extra")] += 1

    stats["final_alloc"] = stats["base"] + stats["extra"]

    return stats, target

#run samplknv chanhe the line 
mode = self.alloc_mode.get()
self.alloc, target = allocate_samples(self.stats, len(df), mode)

#disllah populatikn overview 
txt += f"\nALLOCATION MODE: {self.alloc_mode.get()}\n"
