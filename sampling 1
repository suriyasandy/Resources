import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import numpy as np
from math import ceil

# =========================================================
# CORE LOGIC
# =========================================================

Z_SCORES = {0.90: 1.645, 0.95: 1.96, 0.99: 2.576}

def cochran_sample_size(confidence, error_margin, p=0.5):
    z = Z_SCORES[confidence]
    return ceil((z**2 * p * (1 - p)) / (error_margin**2))

def create_strata(df, region_col, product_col, additional_cols):
    strata = {}
    for idx, row in df.iterrows():
        key = [str(row[region_col]), str(row[product_col])]
        key.extend(str(row[c]) for c in additional_cols)
        strata.setdefault(" | ".join(key), []).append(idx)
    return strata

def adjust_sample_size(base, strata_count):
    if strata_count > 400:
        return max(base, ceil(strata_count * 0.60))
    return base

def risk_allocation(strata, total_records, sample_size):
    risk = []
    for k, idxs in strata.items():
        Nh = len(idxs)
        score = ceil((Nh / total_records) * sample_size)
        if score > 0:
            risk.append({
                "stratum": k,
                "population": Nh,
                "sample": score,
                "indices": idxs
            })
    return sorted(risk, key=lambda x: x["sample"], reverse=True)

def generate_sample(df, risk_table):
    sampled = []
    for r in risk_table:
        if len(r["indices"]) <= r["sample"]:
            sampled.extend(r["indices"])
        else:
            sampled.extend(np.random.choice(r["indices"], r["sample"], replace=False))
    return df.loc[sampled].reset_index(drop=True)

# =========================================================
# TKINTER APP
# =========================================================

class OMRCApp:

    def __init__(self, root):
        self.root = root
        root.title("OMRC Risk-Based Audit Sampling (Core Edition)")
        root.geometry("1000x600")

        self.df = None

        self.build_ui()

    def build_ui(self):
        frame = ttk.Frame(self.root, padding=10)
        frame.pack(fill="both", expand=True)

        # File
        ttk.Label(frame, text="Data File").grid(row=0, column=0, sticky="w")
        self.file_entry = ttk.Entry(frame, width=60)
        self.file_entry.grid(row=0, column=1)
        ttk.Button(frame, text="Browse", command=self.load_file).grid(row=0, column=2)

        # Columns
        ttk.Label(frame, text="Region Column").grid(row=1, column=0, sticky="w")
        ttk.Label(frame, text="Product Column").grid(row=2, column=0, sticky="w")
        ttk.Label(frame, text="Additional Columns (comma-separated)").grid(row=3, column=0, sticky="w")

        self.region_cb = ttk.Combobox(frame)
        self.product_cb = ttk.Combobox(frame)
        self.additional_entry = ttk.Entry(frame, width=60)

        self.region_cb.grid(row=1, column=1, sticky="w")
        self.product_cb.grid(row=2, column=1, sticky="w")
        self.additional_entry.grid(row=3, column=1, sticky="w")

        # Parameters
        ttk.Label(frame, text="Confidence").grid(row=4, column=0, sticky="w")
        ttk.Label(frame, text="Error Margin (%)").grid(row=5, column=0, sticky="w")

        self.confidence_cb = ttk.Combobox(frame, values=[0.90, 0.95, 0.99])
        self.confidence_cb.set(0.95)
        self.error_entry = ttk.Entry(frame)
        self.error_entry.insert(0, "5")

        self.confidence_cb.grid(row=4, column=1, sticky="w")
        self.error_entry.grid(row=5, column=1, sticky="w")

        # Run
        ttk.Button(frame, text="Run Sampling", command=self.run_pipeline).grid(row=6, column=1, pady=10)

        # Output
        self.output = tk.Text(frame, height=15)
        self.output.grid(row=7, column=0, columnspan=3, sticky="nsew")

        frame.rowconfigure(7, weight=1)
        frame.columnconfigure(1, weight=1)

    def load_file(self):
        path = filedialog.askopenfilename(filetypes=[("CSV / Excel", "*.csv *.xlsx")])
        if not path:
            return
        self.file_entry.delete(0, tk.END)
        self.file_entry.insert(0, path)

        self.df = pd.read_csv(path) if path.endswith(".csv") else pd.read_excel(path)
        cols = list(self.df.columns)

        self.region_cb["values"] = cols
        self.product_cb["values"] = cols

        if len(cols) >= 2:
            self.region_cb.set(cols[0])
            self.product_cb.set(cols[1])

    def run_pipeline(self):
        if self.df is None:
            messagebox.showerror("Error", "Load data first")
            return

        region = self.region_cb.get()
        product = self.product_cb.get()
        additional = [c.strip() for c in self.additional_entry.get().split(",") if c.strip()]
        confidence = float(self.confidence_cb.get())
        error = float(self.error_entry.get()) / 100

        base = cochran_sample_size(confidence, error)
        strata = create_strata(self.df, region, product, additional)
        final_n = adjust_sample_size(base, len(strata))
        risk = risk_allocation(strata, len(self.df), final_n)
        sample = generate_sample(self.df, risk)

        self.output.delete("1.0", tk.END)
        self.output.insert(tk.END, f"""
OMRC SAMPLING SUMMARY
====================
Total Records   : {len(self.df)}
Total Strata    : {len(strata)}
Cochran Base    : {base}
Final Sample N  : {final_n}
Sampled Records: {len(sample)}
Coverage %     : {round(len(risk)/len(strata)*100,2)}
""")

# =========================================================
# RUN
# =========================================================

if __name__ == "__main__":
    root = tk.Tk()
    OMRCApp(root)
    root.mainloop()
