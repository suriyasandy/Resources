import streamlit as st
import polars as pl
from pathlib import Path

st.set_page_config(page_title="OMRC – GFX Rule Attribution", layout="wide")

st.title("OMRC – GFX Rule-Delta Attribution Platform")
st.caption("Deterministic | Rule-based | OMRC-safe")

# -----------------------------
# Utility helpers
# -----------------------------
def col_exists(df, col):
    return col in df.columns

def safe_col(df, col, default=None):
    if col_exists(df, col):
        return pl.col(col)
    return pl.lit(default)

# -----------------------------
# Load file (CSV / Parquet)
# -----------------------------
def load_file(uploaded_file):
    suffix = uploaded_file.name.split(".")[-1].lower()
    if suffix == "parquet":
        return pl.read_parquet(uploaded_file)
    elif suffix == "csv":
        return pl.read_csv(uploaded_file, infer_schema_length=10000)
    else:
        st.error("Unsupported file type")
        st.stop()

# -----------------------------
# Core attribution logic
# -----------------------------
def build_attribution(df: pl.DataFrame) -> pl.DataFrame:

    # Compute deviation if missing
    df = df.with_columns([
        pl.when(pl.col("deviation_percent").is_null())
        .then(
            (pl.col("quoted_market_rate") - pl.col("market_rate")).abs()
            / pl.col("market_rate") * 100
        )
        .otherwise(pl.col("deviation_percent"))
        .alias("computed_deviation_percent")
    ])

    # Threshold breach
    df = df.with_columns([
        (pl.col("computed_deviation_percent") - pl.col("base_threshold_percent"))
        .alias("breach_amount_percent")
    ])

    # BTB flag
    df = df.with_columns([
        pl.when(
            (pl.col("bui_value") == "BTB") |
            (pl.col("back_to_back_book") != pl.col("risk_book"))
        )
        .then(pl.lit("YES"))
        .otherwise(pl.lit("NO"))
        .alias("is_btb_trade")
    ])

    # Explanation text (strict dictionary)
    df = df.with_columns([
        pl.when(pl.col("breach_amount_percent") > 0)
        .then(pl.lit("Observed deviation exceeds configured threshold"))
        .otherwise(pl.lit("Observed deviation within configured threshold"))
        .alias("rule_outcome")
    ])

    df = df.with_columns([
        (
            pl.lit("Deviation: ")
            + pl.col("computed_deviation_percent").round(2).cast(pl.Utf8)
            + pl.lit("% | Threshold: ")
            + pl.col("base_threshold_percent").cast(pl.Utf8)
            + pl.lit("% | BTB: ")
            + pl.col("is_btb_trade")
            + pl.lit(" | Market source: ")
            + pl.col("market_rate_source").cast(pl.Utf8)
        ).alias("closure_explanation")
    ])

    return df

# -----------------------------
# Upload latest file
# -----------------------------
uploaded_file = st.file_uploader(
    "Upload Latest GFX Trade File (CSV / Parquet)",
    type=["csv", "parquet"]
)

if uploaded_file:
    with st.spinner("Loading file..."):
        df = load_file(uploaded_file)

    required_cols = [
        "trade_id",
        "ccy_pair",
        "market_rate",
        "quoted_market_rate",
        "quoted_eod_rate",
        "base_threshold_percent",
        "orig_threshold_percent",
        "deviation_percent",
        "market_rate_source",
        "originating_system",
        "bui_value",
        "back_to_back_book",
        "risk_book",
    ]

    missing = [c for c in required_cols if c not in df.columns]
    if missing:
        st.warning(f"Missing columns (handled safely): {missing}")

    df_attr = build_attribution(df)

    st.success(f"Processed {df_attr.height:,} trades")

    # Display table
    st.subheader("Trade-level Rule Attribution")

    display_cols = [
        "trade_id",
        "ccy_pair",
        "computed_deviation_percent",
        "base_threshold_percent",
        "breach_amount_percent",
        "is_btb_trade",
        "rule_outcome",
        "closure_explanation",
    ]

    available_cols = [c for c in display_cols if c in df_attr.columns]

    st.dataframe(
        df_attr.select(available_cols).head(500),
        use_container_width=True
    )

    # Download
    st.download_button(
        "Download Attribution Output",
        df_attr.select(available_cols).write_csv(),
        file_name="omrc_rule_attribution.csv",
        mime="text/csv"
    )
