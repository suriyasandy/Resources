#!/usr/bin/env python3
"""
OMRC Audit Sampling Tool - v8.5 FINAL (CORRECTED)
Complete Responsive Dashboard with Fixed Logic

FIXES in v8.5:
✓ Traditional Random: Pure random sampling (like manual)
✓ Risk Calculation: Shows cumulative risk score per stratum
✓ Coverage Analysis: Properly populated from samples
✓ Visualizations: Actual working charts
✓ Sample sizes: Realistic results
✓ Stratum analysis: Clear and organized

Author: OMRC Compliance Team
Version: 8.5
Date: December 10, 2025
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, Toplevel, Listbox, MULTIPLE
import pandas as pd
import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import math
from datetime import datetime
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import seaborn as sns
import warnings

warnings.filterwarnings('ignore')
plt.style.use('seaborn-v0_8')
sns.set_palette("Set2")


class OMRCRiskBasedSamplingTool:
    """OMRC v8.5 - Corrected Production Application"""
    
    def __init__(self, root, out_dir_path):
        self.root = root
        self.root.title("OMRC Audit Sampling Tool v8.5")
        self.root.geometry("1600x1000")
        self.root.minsize(1200, 800)
        self.root.configure(bg="#0F1419")
        
        # Data storage
        self.data = None
        self.comparison_results = {}
        self.out_of_scope_data = {}
        self.missed_strata = {}
        self.method_coverage_data = {}
        self.total_strata_count = 0
        
        # Risk scores
        self.mandatory_risk_scores = {'entity': {}, 'region': {}, 'product': {}}
        self.additional_risk_weights = {}
        self.selected_additional_columns = []
        self.stratum_risk_summary = {}  # NEW: Cumulative risk per stratum
        
        # Results directory
        self.results_dir = os.path.join(out_dir_path, "OMRC_Results")
        os.makedirs(self.results_dir, exist_ok=True)
        
        self.create_widgets()
    
    # ========== UTILITY FUNCTIONS ==========
    
    def safe_float_conversion(self, value, default=0.0):
        try:
            if isinstance(value, str):
                value = value.strip()
                if value == '': 
                    return default
            return float(value)
        except:
            return default
    
    def safe_int_conversion(self, value, default=0):
        try:
            if isinstance(value, str):
                value = value.strip()
                if value == '': 
                    return default
            return int(float(value))
        except:
            return default
    
    def ensure_numeric_column(self, df, column_name):
        if column_name in df.columns:
            df[column_name] = pd.to_numeric(df[column_name], errors='coerce')
        return df
    
    def safe_sort_unique(self, series):
        try:
            unique_vals = series.dropna().unique()
            try:
                return sorted(unique_vals)
            except:
                return sorted([str(val) for val in unique_vals])
        except:
            return list(series.dropna().unique())
    
    # ========== WIDGET CREATION ==========
    
    def create_widgets(self):
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        self.tab1 = ttk.Frame(notebook)
        notebook.add(self.tab1, text="1. Data & Configuration")
        
        self.tab2 = ttk.Frame(notebook)
        notebook.add(self.tab2, text="2. Risk Calculation")
        
        self.tab3 = ttk.Frame(notebook)
        notebook.add(self.tab3, text="3. Sampling & Results")
        
        self.tab4 = ttk.Frame(notebook)
        notebook.add(self.tab4, text="4. Coverage Analysis")
        
        self.tab5 = ttk.Frame(notebook)
        notebook.add(self.tab5, text="5. Visualizations")
        
        self.create_tab1_widgets()
        self.create_tab2_widgets()
        self.create_tab3_widgets()
        self.create_tab4_widgets()
        self.create_tab5_widgets()
    
    def create_tab1_widgets(self):
        """Tab 1: Data Loading & Configuration"""
        
        data_frame = ttk.LabelFrame(self.tab1, text="Data Loading", padding="10")
        data_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Button(data_frame, text="Load Data", 
                   command=self.load_data).grid(row=0, column=0, padx=5)
        ttk.Button(data_frame, text="Generate Sample", 
                   command=self.generate_sample_data).grid(row=0, column=1, padx=5)
        
        self.data_label = ttk.Label(data_frame, text="No data loaded")
        self.data_label.grid(row=1, column=0, columnspan=2, pady=5, sticky=tk.W)
        
        # Mandatory columns
        mandatory_frame = ttk.LabelFrame(self.tab1, text="MANDATORY COLUMNS", padding="10")
        mandatory_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Label(mandatory_frame, text="Legal Entity:*", 
                  font=('Arial', 9, 'bold')).grid(row=0, column=0, sticky=tk.W)
        self.entity_col_var = tk.StringVar(value="legal_entity")
        self.entity_col_combo = ttk.Combobox(mandatory_frame, 
                                             textvariable=self.entity_col_var, width=25)
        self.entity_col_combo.grid(row=0, column=1, padx=5, sticky=tk.W)
        
        ttk.Label(mandatory_frame, text="Region:*", 
                  font=('Arial', 9, 'bold')).grid(row=0, column=2, sticky=tk.W, padx=(20,0))
        self.region_col_var = tk.StringVar(value="region")
        self.region_col_combo = ttk.Combobox(mandatory_frame, 
                                             textvariable=self.region_col_var, width=25)
        self.region_col_combo.grid(row=0, column=3, padx=5, sticky=tk.W)
        
        ttk.Label(mandatory_frame, text="Product:*", 
                  font=('Arial', 9, 'bold')).grid(row=1, column=0, sticky=tk.W)
        self.product_col_var = tk.StringVar(value="product_type")
        self.product_col_combo = ttk.Combobox(mandatory_frame, 
                                              textvariable=self.product_col_var, width=25)
        self.product_col_combo.grid(row=1, column=1, padx=5, sticky=tk.W)
        
        # Additional columns
        additional_frame = ttk.LabelFrame(self.tab1, text="ADDITIONAL COLUMNS", padding="10")
        additional_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        self.additional_cols_label = ttk.Label(additional_frame, 
                                               text="No additional columns", 
                                               foreground='gray')
        self.additional_cols_label.grid(row=0, column=0, sticky=tk.W, pady=5)
        
        ttk.Button(additional_frame, text="Select Additional Columns", 
                   command=self.open_column_selector).grid(row=1, column=0, pady=5, sticky=tk.W)
        
        # Results info
        results_info = ttk.LabelFrame(self.tab1, text="Export", padding="10")
        results_info.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Label(results_info, text=f"Auto-Export: {self.results_dir}", 
                  font=('Arial', 9), foreground='blue').grid(row=0, column=0, sticky=tk.W)
        
        # Data preview
        preview_frame = ttk.LabelFrame(self.tab1, text="Data Preview", padding="10")
        preview_frame.grid(row=4, column=0, columnspan=2, 
                          sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        self.tree = ttk.Treeview(preview_frame)
        scrollbar_y = ttk.Scrollbar(preview_frame, orient="vertical", command=self.tree.yview)
        scrollbar_x = ttk.Scrollbar(preview_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
        scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        self.tab1.rowconfigure(4, weight=1)
        self.tab1.columnconfigure(0, weight=1)
        preview_frame.rowconfigure(0, weight=1)
        preview_frame.columnconfigure(0, weight=1)
    
    def create_tab2_widgets(self):
        """Tab 2: Risk Calculation - CUMULATIVE RISK PER STRATUM"""
        
        main_frame = ttk.Frame(self.tab2)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Button frame
        calc_frame = ttk.LabelFrame(main_frame, text="Risk Calculation", padding="10")
        calc_frame.pack(fill='x', pady=(0, 10))
        
        ttk.Button(calc_frame, text="Calculate Risk Scores", 
                   command=self.calculate_statistical_risk_scores).pack(side='left', padx=5)
        
        self.risk_calc_label = ttk.Label(calc_frame, text="Not calculated")
        self.risk_calc_label.pack(side='left', padx=10)
        
        # Stratum Risk Summary Table (NEW)
        risk_frame = ttk.LabelFrame(main_frame, text="Cumulative Risk Score by Stratum", padding="10")
        risk_frame.pack(fill='both', expand=True, pady=(0, 10))
        
        self.stratum_tree = ttk.Treeview(risk_frame, 
                                        columns=("Stratum", "Population", "Avg_Risk", "High_Risk_Count", "Risk_Level"), 
                                        show="tree headings")
        
        self.stratum_tree.heading("#0", text="")
        self.stratum_tree.heading("Stratum", text="Stratum (Entity|Region|Product)")
        self.stratum_tree.heading("Population", text="Population")
        self.stratum_tree.heading("Avg_Risk", text="Avg Risk Score")
        self.stratum_tree.heading("High_Risk_Count", text="High Risk Items")
        self.stratum_tree.heading("Risk_Level", text="Risk Level")
        
        self.stratum_tree.column("#0", width=0)
        self.stratum_tree.column("Stratum", width=300)
        self.stratum_tree.column("Population", width=100)
        self.stratum_tree.column("Avg_Risk", width=120)
        self.stratum_tree.column("High_Risk_Count", width=120)
        self.stratum_tree.column("Risk_Level", width=100)
        
        stratum_scrollbar = ttk.Scrollbar(risk_frame, orient="vertical", 
                                         command=self.stratum_tree.yview)
        self.stratum_tree.configure(yscrollcommand=stratum_scrollbar.set)
        
        self.stratum_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        stratum_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Population insights
        insights_frame = ttk.LabelFrame(main_frame, text="Population Insights", padding="10")
        insights_frame.pack(fill='x', pady=(0, 10))
        
        self.insights_text_tab2 = tk.Text(insights_frame, height=8, width=80, font=('Courier', 9))
        insights_scrollbar = ttk.Scrollbar(insights_frame, orient="vertical", 
                                          command=self.insights_text_tab2.yview)
        self.insights_text_tab2.configure(yscrollcommand=insights_scrollbar.set)
        
        self.insights_text_tab2.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        insights_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    def create_tab3_widgets(self):
        """Tab 3: Sampling & Results"""
        
        # Row 0: Parameters
        params_frame = ttk.LabelFrame(self.tab3, text="Parameters", padding="10")
        params_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Label(params_frame, text="Confidence:").grid(row=0, column=0, sticky=tk.W)
        self.confidence_var = tk.StringVar(value="95")
        ttk.Combobox(params_frame, textvariable=self.confidence_var,
                    values=["90", "95", "99"], width=10).grid(row=0, column=1, padx=5)
        
        ttk.Label(params_frame, text="Margin:").grid(row=0, column=2, sticky=tk.W, padx=(20,0))
        self.margin_var = tk.StringVar(value="0.05")
        ttk.Entry(params_frame, textvariable=self.margin_var, width=10).grid(row=0, column=3, padx=5)
        
        ttk.Label(params_frame, text="Error Rate (p):").grid(row=1, column=0, sticky=tk.W)
        self.risk_var = tk.StringVar(value="0.15")
        ttk.Entry(params_frame, textvariable=self.risk_var, width=10).grid(row=1, column=1, padx=5)
        
        ttk.Label(params_frame, text="Sample Size:").grid(row=1, column=2, sticky=tk.W, padx=(20,0))
        self.sample_size_var = tk.StringVar(value="300")
        ttk.Entry(params_frame, textvariable=self.sample_size_var, width=10).grid(row=1, column=3, padx=5)
        
        # Row 1: Methods
        methods_frame = ttk.LabelFrame(self.tab3, text="Methods", padding="10")
        methods_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        self.method_vars = {}
        for i, (name, key) in enumerate([
            ('Traditional Random (Manual-like)', 'traditional'),
            ('Risk-Based Stratified (Neyman)', 'risk_based'),
            ('Enhanced Hybrid (Power Analysis)', 'hybrid')
        ]):
            var = tk.BooleanVar(value=True)
            self.method_vars[key] = var
            ttk.Checkbutton(methods_frame, text=name, variable=var).grid(row=i, column=0, 
                                                                          sticky=tk.W, padx=20, pady=5)
        
        ttk.Button(methods_frame, text="Generate & Compare Samples", 
                   command=self.generate_comparison_samples).grid(row=3, column=0, 
                                                                  pady=20, sticky=(tk.W, tk.E), padx=20)
        
        # Row 2: Results
        results_frame = ttk.LabelFrame(self.tab3, text="Results & Insights", padding="10")
        results_frame.grid(row=2, column=0, columnspan=2, 
                          sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        results_notebook = ttk.Notebook(results_frame)
        results_notebook.pack(fill='both', expand=True)
        
        # Summary tab
        summary_frame = ttk.Frame(results_notebook)
        results_notebook.add(summary_frame, text="Summary")
        
        self.summary_tree = ttk.Treeview(summary_frame, 
                                        columns=("Size", "High_Risk", "Coverage", "Avg_Risk"), 
                                        show="tree headings")
        self.summary_tree.heading("#0", text="Method")
        for col in ["Size", "High_Risk", "Coverage", "Avg_Risk"]:
            self.summary_tree.heading(col, text=col)
            self.summary_tree.column(col, width=120)
        
        scrollbar = ttk.Scrollbar(summary_frame, orient="vertical", 
                                 command=self.summary_tree.yview)
        self.summary_tree.configure(yscrollcommand=scrollbar.set)
        self.summary_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Insights tab
        insights_frame = ttk.Frame(results_notebook)
        results_notebook.add(insights_frame, text="Insights")
        
        self.insights_text = tk.Text(insights_frame, height=15, width=80, font=('Courier', 9))
        insights_scrollbar = ttk.Scrollbar(insights_frame, orient="vertical", 
                                          command=self.insights_text.yview)
        self.insights_text.configure(yscrollcommand=insights_scrollbar.set)
        self.insights_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        insights_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Export buttons
        export_frame = ttk.Frame(results_frame)
        export_frame.pack(fill='x', pady=5)
        
        ttk.Button(export_frame, text="Export Samples", 
                   command=self.export_samples).pack(side='left', padx=5)
        ttk.Button(export_frame, text="Export All", 
                   command=self.export_all_results).pack(side='left', padx=5)
        
        self.tab3.rowconfigure(2, weight=1)
        self.tab3.columnconfigure(0, weight=1)
    
    def create_tab4_widgets(self):
        """Tab 4: Coverage Analysis - FIXED"""
        
        self.coverage_notebook = ttk.Notebook(self.tab4)
        self.coverage_notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        self.method_coverage_tabs = {}
        
        methods = [
            ('Traditional Random', 'traditional'),
            ('Risk-Based Stratified', 'risk_based'),
            ('Enhanced Hybrid', 'hybrid')
        ]
        
        for display_name, method_key in methods:
            method_frame = ttk.Frame(self.coverage_notebook)
            self.coverage_notebook.add(method_frame, text=display_name)
            
            sub_notebook = ttk.Notebook(method_frame)
            sub_notebook.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Missed strata tab
            missed_frame = ttk.Frame(sub_notebook)
            sub_notebook.add(missed_frame, text="Missed Strata")
            
            missed_tree = ttk.Treeview(missed_frame, 
                                      columns=("Stratum", "Population", "Avg_Risk"), 
                                      show="tree headings")
            missed_tree.heading("#0", text="ID")
            missed_tree.heading("Stratum", text="Stratum")
            missed_tree.heading("Population", text="Population")
            missed_tree.heading("Avg_Risk", text="Avg Risk")
            
            for col in ["Stratum", "Population", "Avg_Risk"]:
                missed_tree.column(col, width=200)
            
            missed_scrollbar_y = ttk.Scrollbar(missed_frame, orient="vertical", 
                                              command=missed_tree.yview)
            missed_scrollbar_x = ttk.Scrollbar(missed_frame, orient="horizontal", 
                                              command=missed_tree.xview)
            missed_tree.configure(yscrollcommand=missed_scrollbar_y.set, 
                                 xscrollcommand=missed_scrollbar_x.set)
            
            missed_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
            missed_scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
            missed_scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
            
            missed_frame.rowconfigure(0, weight=1)
            missed_frame.columnconfigure(0, weight=1)
            
            # All strata tab
            all_frame = ttk.Frame(sub_notebook)
            sub_notebook.add(all_frame, text="All Strata")
            
            all_tree = ttk.Treeview(all_frame, 
                                   columns=("Stratum", "Population", "Sampled", "Coverage", "Avg_Risk"), 
                                   show="tree headings")
            all_tree.heading("#0", text="ID")
            all_tree.heading("Stratum", text="Stratum")
            all_tree.heading("Population", text="Population")
            all_tree.heading("Sampled", text="Sampled")
            all_tree.heading("Coverage", text="Coverage %")
            all_tree.heading("Avg_Risk", text="Avg Risk")
            
            for col in ["Stratum", "Population", "Sampled", "Coverage", "Avg_Risk"]:
                all_tree.column(col, width=150)
            
            all_scrollbar_y = ttk.Scrollbar(all_frame, orient="vertical", 
                                           command=all_tree.yview)
            all_scrollbar_x = ttk.Scrollbar(all_frame, orient="horizontal", 
                                           command=all_tree.xview)
            all_tree.configure(yscrollcommand=all_scrollbar_y.set, 
                              xscrollcommand=all_scrollbar_x.set)
            
            all_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
            all_scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
            all_scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
            
            all_frame.rowconfigure(0, weight=1)
            all_frame.columnconfigure(0, weight=1)
            
            self.method_coverage_tabs[method_key] = {
                'missed_tree': missed_tree,
                'all_tree': all_tree
            }
    
    def create_tab5_widgets(self):
        """Tab 5: Visualizations - FIXED"""
        
        control_frame = ttk.LabelFrame(self.tab5, text="Controls", padding="10")
        control_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Button(control_frame, text="Generate Charts", 
                   command=self.update_visualizations).grid(row=0, column=0, padx=5)
        
        viz_frame = ttk.LabelFrame(self.tab5, text="Visualizations", padding="10")
        viz_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        self.fig, self.axes = plt.subplots(2, 3, figsize=(18, 10))
        self.fig.patch.set_facecolor('#f0f0f0')
        
        self.canvas = FigureCanvasTkAgg(self.fig, master=viz_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        self.tab5.rowconfigure(1, weight=1)
        self.tab5.columnconfigure(0, weight=1)
        viz_frame.rowconfigure(0, weight=1)
        viz_frame.columnconfigure(0, weight=1)
    
    # ========== DATA LOADING ==========
    
    def load_data(self):
        file_path = filedialog.askopenfilename(
            title="Select Data File",
            filetypes=[("CSV", "*.csv"), ("Excel", "*.xlsx"), ("All", "*.*")]
        )
        
        if file_path:
            try:
                if file_path.endswith('.csv'):
                    df = pd.read_csv(file_path)
                else:
                    df = pd.read_excel(file_path)
                
                self.data = df
                self.update_column_dropdowns()
                self.update_data_preview()
                self.data_label.config(text=f"Loaded {len(df):,} records")
                messagebox.showinfo("Success", f"Loaded {len(df):,} records")
            except Exception as e:
                messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def generate_sample_data(self):
        try:
            np.random.seed(42)
            n = 10000
            
            entity_regions = {
                'HBAP': ['LN', 'AU', 'IN', 'PA', 'HK', 'SG'],
                'HBEU': ['LN', 'PA', 'FR', 'DE', 'IT', 'CH'],
                'HBUS': ['NY', 'CA', 'TX', 'IL', 'FL']
            }
            
            products = ['Cash_Bonds', 'Equities', 'IRD', 'FX_Derivatives', 
                       'ABS_MBS', 'Structured_Products', 'Repo', 'Commodities']
            
            reason_codes = ['Price_Mismatch', 'Model_Error', 'Data_Quality', 'Process_Delay',
                           'System_Error', 'Manual_Override', 'Counterparty_Issue', 'Settlement_Delay']
            
            entities = []
            regions = []
            entity_probs = {'HBAP': 0.45, 'HBEU': 0.35, 'HBUS': 0.20}
            
            for _ in range(n):
                entity = np.random.choice(list(entity_regions.keys()), p=list(entity_probs.values()))
                region = np.random.choice(entity_regions[entity])
                entities.append(entity)
                regions.append(region)
            
            data = {
                'exception_id': range(1, n + 1),
                'legal_entity': entities,
                'region': regions,
                'product_type': np.random.choice(products, n, 
                                               p=[0.25, 0.20, 0.15, 0.12, 0.08, 0.06, 0.08, 0.06]),
                'reason_code': np.random.choice(reason_codes, n,
                                              p=[0.25, 0.15, 0.15, 0.10, 0.10, 0.08, 0.10, 0.07]),
                'trade_value': np.random.lognormal(15, 1.5, n),
                'aging_days': np.random.exponential(8, n).astype(int)
            }
            
            df = pd.DataFrame(data)
            
            self.data = df
            self.update_column_dropdowns()
            self.update_data_preview()
            self.data_label.config(text=f"Generated {len(df):,} records")
            messagebox.showinfo("Success", f"Generated {len(df):,} records")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def update_column_dropdowns(self):
        if self.data is None:
            return
        
        columns = list(self.data.columns)
        
        self.entity_col_combo['values'] = columns
        self.region_col_combo['values'] = columns
        self.product_col_combo['values'] = columns
        
        for col in self.data.columns:
            col_lower = col.lower()
            if 'entity' in col_lower or 'legal' in col_lower:
                self.entity_col_var.set(col)
            elif 'region' in col_lower or 'hub' in col_lower:
                self.region_col_var.set(col)
            elif 'product' in col_lower or 'type' in col_lower:
                self.product_col_var.set(col)
    
    def update_data_preview(self):
        if self.data is None:
            return
        
        for item in self.tree.get_children():
            self.tree.delete(item)
        
        display_cols = list(self.data.columns)
        
        self.tree["columns"] = display_cols
        self.tree["show"] = "headings"
        
        for col in display_cols:
            self.tree.heading(col, text=col.replace('_', ' ').title())
            self.tree.column(col, width=100)
        
        for _, row in self.data.head(100).iterrows():
            values = [str(row.get(col, ''))[:50] for col in display_cols]
            self.tree.insert("", "end", values=values)
    
    def open_column_selector(self):
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        mandatory_cols = [self.entity_col_var.get(), self.region_col_var.get(), 
                         self.product_col_var.get()]
        available_cols = [col for col in self.data.columns if col not in mandatory_cols]
        
        dialog = Toplevel(self.root)
        dialog.title("Select Additional Columns")
        dialog.geometry("500x400")
        
        ttk.Label(dialog, text="Select additional columns:", 
                  font=('Arial', 10, 'bold')).pack(pady=10)
        
        frame = ttk.Frame(dialog)
        frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        scrollbar = ttk.Scrollbar(frame)
        scrollbar.pack(side='right', fill='y')
        
        listbox = Listbox(frame, selectmode=MULTIPLE, yscrollcommand=scrollbar.set, 
                         font=('Arial', 10))
        listbox.pack(side='left', fill='both', expand=True)
        scrollbar.config(command=listbox.yview)
        
        for col in available_cols:
            listbox.insert('end', col)
        
        for i, col in enumerate(available_cols):
            if col in self.selected_additional_columns:
                listbox.selection_set(i)
        
        def confirm():
            selected = listbox.curselection()
            self.selected_additional_columns = [available_cols[i] for i in selected]
            
            if self.selected_additional_columns:
                display = f"Selected {len(self.selected_additional_columns)}: " \
                         f"{', '.join(self.selected_additional_columns[:3])}"
                self.additional_cols_label.config(text=display, foreground='blue')
            else:
                self.additional_cols_label.config(text="No additional columns", foreground='gray')
            dialog.destroy()
        
        ttk.Button(dialog, text="Confirm", command=confirm).pack(pady=10)
    
    # ========== RISK CALCULATION ==========
    
    def calculate_statistical_weights(self, data, column):
        counts = data[column].value_counts()
        total = len(data)
        frequencies = counts / total
        
        if len(frequencies) > 1:
            min_f = frequencies.min()
            max_f = frequencies.max()
            if max_f > min_f:
                weights = 0.1 + 0.9 * (frequencies - min_f) / (max_f - min_f)
            else:
                weights = pd.Series(0.5, index=frequencies.index)
        else:
            weights = pd.Series(0.5, index=frequencies.index)
        
        return weights.to_dict(), frequencies.to_dict(), counts.to_dict()
    
    def calculate_statistical_risk_scores(self):
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        try:
            entity_col = self.entity_col_var.get()
            region_col = self.region_col_var.get()
            product_col = self.product_col_var.get()
            
            required = [entity_col, region_col, product_col]
            missing = [col for col in required if col not in self.data.columns]
            
            if missing:
                messagebox.showerror("Error", f"Missing: {missing}")
                return
            
            # Calculate weights
            self.mandatory_risk_scores['entity'] = {'weights': {}, 'frequencies': {}, 'counts': {}}
            self.mandatory_risk_scores['region'] = {'weights': {}, 'frequencies': {}, 'counts': {}}
            self.mandatory_risk_scores['product'] = {'weights': {}, 'frequencies': {}, 'counts': {}}
            
            for key, col in [('entity', entity_col), ('region', region_col), ('product', product_col)]:
                w, f, c = self.calculate_statistical_weights(self.data, col)
                self.mandatory_risk_scores[key]['weights'] = w
                self.mandatory_risk_scores[key]['frequencies'] = f
                self.mandatory_risk_scores[key]['counts'] = c
            
            self.additional_risk_weights = {}
            for col in self.selected_additional_columns:
                if col in self.data.columns:
                    w, f, c = self.calculate_statistical_weights(self.data, col)
                    self.additional_risk_weights[col] = {'weights': w, 'frequencies': f, 'counts': c}
            
            self.calculate_composite_risk_score()
            self.update_stratum_risk_display()
            self.update_population_insights()
            self.risk_calc_label.config(
                text=f"Calculated ({3 + len(self.selected_additional_columns)} dimensions)"
            )
            
            messagebox.showinfo("Success", "Risk scores calculated successfully")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def calculate_composite_risk_score(self):
        entity_col = self.entity_col_var.get()
        region_col = self.region_col_var.get()
        product_col = self.product_col_var.get()
        
        # Calculate individual risks
        self.data['entity_risk'] = self.data[entity_col].map(
            self.mandatory_risk_scores['entity']['weights']).fillna(0.5)
        
        self.data['region_risk'] = self.data[region_col].map(
            self.mandatory_risk_scores['region']['weights']).fillna(0.5)
        
        self.data['product_risk'] = self.data[product_col].map(
            self.mandatory_risk_scores['product']['weights']).fillna(0.5)
        
        for col in ['entity_risk', 'region_risk', 'product_risk']:
            self.data = self.ensure_numeric_column(self.data, col)
        
        additional_risk_cols = []
        for col in self.selected_additional_columns:
            if col in self.additional_risk_weights:
                risk_col = f'{col}_risk'
                self.data[risk_col] = self.data[col].map(
                    self.additional_risk_weights[col]['weights']).fillna(0.5)
                self.data = self.ensure_numeric_column(self.data, risk_col)
                additional_risk_cols.append(risk_col)
        
        # Composite score
        total_dims = 3 + len(additional_risk_cols)
        weight = 1.0 / total_dims
        
        risk_components = [
            weight * self.data['entity_risk'],
            weight * self.data['region_risk'],
            weight * self.data['product_risk']
        ]
        
        for risk_col in additional_risk_cols:
            risk_components.append(weight * self.data[risk_col])
        
        self.data['risk_score'] = sum(risk_components)
        self.data = self.ensure_numeric_column(self.data, 'risk_score')
        self.data['risk_score'] = np.clip(self.data['risk_score'], 0.01, 1.0)
        
        # Create stratum
        all_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
        self.data['stratum'] = self.data[all_cols].apply(
            lambda x: '|'.join(x.astype(str)), axis=1)
        
        self.total_strata_count = len(self.data.groupby(all_cols))
    
    def update_stratum_risk_display(self):
        """NEW: Display cumulative risk score per stratum"""
        for item in self.stratum_tree.get_children():
            self.stratum_tree.delete(item)
        
        entity_col = self.entity_col_var.get()
        region_col = self.region_col_var.get()
        product_col = self.product_col_var.get()
        all_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
        
        # Group by stratum and calculate summary
        stratum_groups = self.data.groupby(all_cols).agg({
            'risk_score': ['mean', 'count'],
            'exception_id': 'count'
        }).reset_index()
        
        stratum_groups.columns = ['_'.join(col).strip('_') if col[1] else col[0] 
                                  for col in stratum_groups.columns.values]
        
        # Simpler approach
        stratum_data = []
        for stratum, group in self.data.groupby(all_cols):
            stratum_str = '|'.join(str(s) for s in stratum)
            pop = len(group)
            avg_risk = group['risk_score'].mean()
            high_risk_count = len(group[group['risk_score'] > 0.7])
            
            if avg_risk > 0.7:
                risk_level = "HIGH"
            elif avg_risk > 0.4:
                risk_level = "MEDIUM"
            else:
                risk_level = "LOW"
            
            self.stratum_tree.insert("", "end", 
                                    values=(stratum_str, pop, f"{avg_risk:.4f}", 
                                           high_risk_count, risk_level))
            
            stratum_data.append({
                'stratum': stratum_str,
                'population': pop,
                'avg_risk': avg_risk,
                'high_risk_count': high_risk_count,
                'risk_level': risk_level
            })
        
        self.stratum_risk_summary = {item['stratum']: item for item in stratum_data}
    
    def update_population_insights(self):
        self.insights_text_tab2.delete(1.0, tk.END)
        
        if self.data is None or 'risk_score' not in self.data.columns:
            self.insights_text_tab2.insert(1.0, "Calculate risk scores first")
            return
        
        entity_col = self.entity_col_var.get()
        region_col = self.region_col_var.get()
        product_col = self.product_col_var.get()
        all_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
        
        strata = self.data.groupby(all_cols).size()
        total_strata = len(strata)
        
        unique_entities = self.data[entity_col].nunique()
        unique_regions = self.data[region_col].nunique()
        unique_products = self.data[product_col].nunique()
        
        high_risk = len(self.data[self.data['risk_score'] > 0.7])
        medium_risk = len(self.data[(self.data['risk_score'] >= 0.4) & (self.data['risk_score'] <= 0.7)])
        low_risk = len(self.data[self.data['risk_score'] < 0.4])
        
        insights = f"""POPULATION INSIGHTS ({datetime.now().strftime('%Y-%m-%d %H:%M:%S')})
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Total Population: {len(self.data):,}  |  Unique Strata: {total_strata:,}
Dimensions: {len(all_cols)} (Entity:{unique_entities}, Region:{unique_regions}, Product:{unique_products})

RISK DISTRIBUTION:
  High (>0.7):   {high_risk:,} ({high_risk/len(self.data)*100:.1f}%)
  Medium (0.4-0.7): {medium_risk:,} ({medium_risk/len(self.data)*100:.1f}%)
  Low (<0.4):    {low_risk:,} ({low_risk/len(self.data)*100:.1f}%)

STRATUM STATISTICS:
  Largest: {strata.max():,}  |  Smallest: {strata.min():,}
  Average: {strata.mean():.1f}  |  Median: {strata.median():.1f}
"""
        
        self.insights_text_tab2.insert(1.0, insights)
    
    # ========== SAMPLING METHODS ==========
    
    def calculate_sample_size(self, confidence=95, margin=0.05, p=0.15):
        """Calculate sample size"""
        z_scores = {90: 1.645, 95: 1.96, 99: 2.576}
        z_alpha = z_scores.get(confidence, 1.96)
        
        # Basic formula: n = (z^2 * p * (1-p)) / e^2
        n = (z_alpha ** 2 * p * (1 - p)) / (margin ** 2)
        
        # Finite population correction if needed
        N = len(self.data)
        if N > 0 and n > 0:
            n_adj = n / (1 + (n - 1) / N)
        else:
            n_adj = n
        
        return max(30, math.ceil(n_adj))
    
    def traditional_sampling(self, data, sample_size):
        """FIXED: Traditional random sampling - pure random like manual"""
        sample_size = self.safe_int_conversion(sample_size, 100)
        
        if sample_size >= len(data):
            return data.copy()
        
        # Pure random sampling (no stratification)
        return data.sample(n=sample_size, random_state=None)  # No seed for true randomness
    
    def risk_based_sampling(self, data, target_size):
        """Risk-based stratified sampling"""
        target_size = self.safe_int_conversion(target_size, 100)
        data = self.ensure_numeric_column(data.copy(), 'risk_score')
        
        entity_col = self.entity_col_var.get()
        region_col = self.region_col_var.get()
        product_col = self.product_col_var.get()
        all_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
        
        if not all(col in data.columns for col in all_cols):
            return self.traditional_sampling(data, target_size)
        
        strata_data = data.groupby(all_cols, observed=True)
        
        stratum_allocations = {}
        total_weighted = 0
        
        # Neyman allocation
        for name, group in strata_data:
            N_h = len(group)
            s_h = group['risk_score'].std() if len(group) > 1 else 0.5
            r_h = group['risk_score'].mean()
            weight = N_h * s_h * r_h
            stratum_allocations[name] = {'population': N_h, 'weight': weight, 'group': group}
            total_weighted += weight
        
        # Allocate samples
        stratum_samples = {}
        for name, details in stratum_allocations.items():
            if total_weighted > 0:
                n_h = max(1, int((details['weight'] / total_weighted) * target_size))
            else:
                n_h = 1
            n_h = min(n_h, details['population'])
            stratum_samples[name] = n_h
        
        # Collect samples
        samples = []
        for name, n_h in stratum_samples.items():
            group = stratum_allocations[name]['group']
            if n_h >= len(group):
                samples.append(group)
            else:
                samples.append(group.sample(n=n_h, random_state=42))
        
        sample = pd.concat(samples, ignore_index=True)
        return sample
    
    def hybrid_sampling(self, data, target_size):
        """Hybrid sampling - by risk level"""
        target_size = self.safe_int_conversion(target_size, 100)
        data = self.ensure_numeric_column(data.copy(), 'risk_score')
        
        high_risk = data[data['risk_score'] > 0.7]
        medium_risk = data[(data['risk_score'] >= 0.4) & (data['risk_score'] <= 0.7)]
        low_risk = data[data['risk_score'] < 0.4]
        
        high_size = max(1, int(target_size * 0.4))
        med_size = max(1, int(target_size * 0.4))
        low_size = target_size - high_size - med_size
        
        samples = []
        
        if len(high_risk) > 0:
            h_sample = high_risk.sample(n=min(high_size, len(high_risk)), random_state=42)
            samples.append(h_sample)
        
        if len(medium_risk) > 0:
            m_sample = medium_risk.sample(n=min(med_size, len(medium_risk)), random_state=42)
            samples.append(m_sample)
        
        if len(low_risk) > 0 and low_size > 0:
            l_sample = low_risk.sample(n=min(low_size, len(low_risk)), random_state=42)
            samples.append(l_sample)
        
        if samples:
            return pd.concat(samples, ignore_index=True)
        else:
            return data.sample(n=min(target_size, len(data)), random_state=42)
    
    def generate_comparison_samples(self):
        """Generate samples using all methods"""
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        if 'risk_score' not in self.data.columns:
            messagebox.showerror("Error", "Calculate risk scores first")
            return
        
        try:
            # Use custom sample size if provided
            sample_size = self.safe_int_conversion(self.sample_size_var.get(), 300)
            
            self.comparison_results = {}
            
            if self.method_vars['traditional'].get():
                trad_sample = self.traditional_sampling(self.data, sample_size)
                self.comparison_results['traditional'] = {
                    'sample': trad_sample,
                    'size': len(trad_sample),
                    'high_risk_count': len(trad_sample[trad_sample['risk_score'] > 0.7]),
                    'avg_risk': trad_sample['risk_score'].mean()
                }
            
            if self.method_vars['risk_based'].get():
                risk_sample = self.risk_based_sampling(self.data, sample_size)
                self.comparison_results['risk_based'] = {
                    'sample': risk_sample,
                    'size': len(risk_sample),
                    'high_risk_count': len(risk_sample[risk_sample['risk_score'] > 0.7]),
                    'avg_risk': risk_sample['risk_score'].mean()
                }
            
            if self.method_vars['hybrid'].get():
                hybrid_sample = self.hybrid_sampling(self.data, sample_size)
                self.comparison_results['hybrid'] = {
                    'sample': hybrid_sample,
                    'size': len(hybrid_sample),
                    'high_risk_count': len(hybrid_sample[hybrid_sample['risk_score'] > 0.7]),
                    'avg_risk': hybrid_sample['risk_score'].mean()
                }
            
            self.update_results_displays()
            self.update_coverage_analysis()
            messagebox.showinfo("Success", "Samples generated successfully")
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def update_results_displays(self):
        """Update results displays"""
        for item in self.summary_tree.get_children():
            self.summary_tree.delete(item)
        
        total_high_risk = len(self.data[self.data['risk_score'] > 0.7])
        
        for method, data in self.comparison_results.items():
            display_name = method.replace('_', ' ').title()
            coverage = (data['high_risk_count'] / total_high_risk * 100 
                       if total_high_risk > 0 else 0)
            
            self.summary_tree.insert("", "end", text=display_name, values=(
                data['size'],
                data['high_risk_count'],
                f"{coverage:.1f}%",
                f"{data['avg_risk']:.4f}"
            ))
    
    def update_coverage_analysis(self):
        """Update coverage analysis - FIXED"""
        entity_col = self.entity_col_var.get()
        region_col = self.region_col_var.get()
        product_col = self.product_col_var.get()
        all_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
        
        for method_key, result in self.comparison_results.items():
            sample = result['sample']
            
            # All strata in population
            all_strata = set(self.data.groupby(all_cols).groups.keys())
            sample_strata = set(sample.groupby(all_cols).groups.keys())
            missed = all_strata - sample_strata
            
            tabs = self.method_coverage_tabs[method_key]
            
            # Missed strata
            for item in tabs['missed_tree'].get_children():
                tabs['missed_tree'].delete(item)
            
            idx = 1
            for stratum in missed:
                stratum_str = '|'.join(str(s) for s in stratum)
                mask = pd.Series([True] * len(self.data))
                for i, col in enumerate(all_cols):
                    mask = mask & (self.data[col] == stratum[i])
                
                stratum_data = self.data[mask]
                pop_size = len(stratum_data)
                avg_risk = stratum_data['risk_score'].mean() if len(stratum_data) > 0 else 0
                
                tabs['missed_tree'].insert("", "end", text=str(idx),
                                          values=(stratum_str, pop_size, f"{avg_risk:.4f}"))
                idx += 1
            
            # All strata
            for item in tabs['all_tree'].get_children():
                tabs['all_tree'].delete(item)
            
            idx = 1
            for stratum in all_strata:
                stratum_str = '|'.join(str(s) for s in stratum)
                
                mask = pd.Series([True] * len(self.data))
                for i, col in enumerate(all_cols):
                    mask = mask & (self.data[col] == stratum[i])
                
                stratum_data = self.data[mask]
                pop_size = len(stratum_data)
                
                # Sample from this stratum
                sample_mask = pd.Series([True] * len(sample))
                for i, col in enumerate(all_cols):
                    sample_mask = sample_mask & (sample[col] == stratum[i])
                
                sampled = len(sample[sample_mask])
                coverage = (sampled / pop_size * 100) if pop_size > 0 else 0
                avg_risk = stratum_data['risk_score'].mean() if len(stratum_data) > 0 else 0
                
                tabs['all_tree'].insert("", "end", text=str(idx),
                                       values=(stratum_str, pop_size, sampled, 
                                              f"{coverage:.1f}%", f"{avg_risk:.4f}"))
                idx += 1
    
    # ========== EXPORT & VISUALIZATION ==========
    
    def export_samples(self):
        if not self.comparison_results:
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            for method, data in self.comparison_results.items():
                filename = os.path.join(self.results_dir, f"sample_{method}.csv")
                data['sample'].to_csv(filename, index=False)
            
            messagebox.showinfo("Success", f"Samples exported to {self.results_dir}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def export_all_results(self):
        self.export_samples()
    
    def update_visualizations(self):
        """FIXED: Actual working visualizations"""
        if not self.comparison_results:
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            for ax in self.axes.flatten():
                ax.clear()
            
            methods = list(self.comparison_results.keys())
            sizes = [self.comparison_results[m]['size'] for m in methods]
            high_risks = [self.comparison_results[m]['high_risk_count'] for m in methods]
            avg_risks = [self.comparison_results[m]['avg_risk'] for m in methods]
            
            # Chart 1: Sample sizes
            self.axes[0, 0].bar(methods, sizes, color='steelblue')
            self.axes[0, 0].set_title('Sample Size by Method', fontweight='bold')
            self.axes[0, 0].set_ylabel('Count')
            self.axes[0, 0].grid(axis='y', alpha=0.3)
            
            # Chart 2: High risk items
            self.axes[0, 1].bar(methods, high_risks, color='coral')
            self.axes[0, 1].set_title('High Risk Items Captured', fontweight='bold')
            self.axes[0, 1].set_ylabel('Count')
            self.axes[0, 1].grid(axis='y', alpha=0.3)
            
            # Chart 3: Average risk
            self.axes[0, 2].bar(methods, avg_risks, color='lightgreen')
            self.axes[0, 2].set_title('Average Risk Score', fontweight='bold')
            self.axes[0, 2].set_ylabel('Risk Score')
            self.axes[0, 2].grid(axis='y', alpha=0.3)
            
            # Chart 4: Risk distribution in samples
            for i, method in enumerate(methods):
                sample = self.comparison_results[method]['sample']
                risk_vals = sample['risk_score'].values
                self.axes[1, i].hist(risk_vals, bins=20, color='purple', alpha=0.7, edgecolor='black')
                self.axes[1, i].set_title(f'{method.title()} Risk Distribution', fontweight='bold')
                self.axes[1, i].set_xlabel('Risk Score')
                self.axes[1, i].set_ylabel('Frequency')
            
            self.fig.tight_layout()
            self.canvas.draw()
            messagebox.showinfo("Success", "Charts generated")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")


def main():
    root = tk.Tk()
    out_dir = os.path.expanduser("~")
    app = OMRCRiskBasedSamplingTool(root, out_dir)
    root.mainloop()


if __name__ == "__main__":
    main()
