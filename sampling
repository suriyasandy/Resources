"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         OMRC RISK-BASED SAMPLING TOOL v4.0 - SIMPLIFIED & STREAMLINED         â•‘
â•‘              Dynamic Column Selection + Data Preview + Numeric Coercion        â•‘
â•‘              4 SIMPLE TABS: Load | Analyze | Sample | Export                  â•‘
â•‘                    UI SIMPLIFIED - Production Ready                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FILE: OMRC_RiskBasedSampling_v400_Simplified.py
VERSION: 4.0 - Simplified UI with fixed float/string error
DATE: December 9, 2025
STATUS: âœ“ PRODUCTION READY

CRITICAL FIXES:
  âœ“ Fixed '<' not supported between float and str error (numeric coercion)
  âœ“ Dynamic mandatory column dropdowns (based on loaded data)
  âœ“ Data preview table (shows first 50 rows)
  âœ“ Simplified to 4 main tabs (user-friendly)
  âœ“ All analysis consolidated in single tabs
  âœ“ Robust anomaly detection with fallback

UI FEATURES (4 TABS - STREAMLINED):
  âœ“ Tab 1: Load & Configure (Data loading, column selection, preview)
  âœ“ Tab 2: Analyze (Risk scores + Coverage in one view)
  âœ“ Tab 3: Sample & Compare (All sampling methods + charts)
  âœ“ Tab 4: Export & Results (All exports + detailed reports)

INSTALLATION:
  pip install pandas numpy scikit-learn matplotlib seaborn openpyxl

RUN:
  python OMRC_RiskBasedSampling_v400_Simplified.py
"""

import tkinter as tk
from tkinter import filedialog, messagebox, ttk, Listbox, Toplevel, MULTIPLE
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import seaborn as sns
from sklearn.ensemble import IsolationForest
import math
import os
from datetime import datetime
import warnings

warnings.filterwarnings('ignore')

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CORE SAMPLING CLASS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class OMRCRiskBasedSampling:
    """OMRC Risk-Based Sampling Engine with Two-Phase Allocation"""
    
    def __init__(self):
        self.data = None
        self.stratum_columns = []
        self.samples = {}
        self.stratum_allocations = {}
        self.results_dir = "Results_v400"
        self.create_results_directory()
    
    def create_results_directory(self):
        """Create results directory if it doesn't exist"""
        if not os.path.exists(self.results_dir):
            os.makedirs(self.results_dir)
    
    def coerce_numeric_columns(self, data):
        """
        FIX: Convert string-looking numeric columns to actual numeric type.
        This prevents '<' not supported between float and str error.
        """
        data = data.copy()
        for col in data.columns:
            try:
                converted = pd.to_numeric(data[col], errors='coerce')
                # If conversion worked for most values, keep it
                if converted.notna().sum() / len(data) > 0.5:
                    data[col] = converted
            except:
                pass  # Keep original if conversion fails
        return data
    
    def calculate_dynamic_risk_scores(self, data, stratum_columns):
        """Calculate dynamic risk scores based on stratification structure"""
        data = data.copy()
        total_pop = len(data)
        
        # Initialize risk_score column
        data['risk_score'] = 0.0
        
        try:
            stratum_groups = data.groupby(stratum_columns, observed=True)
            
            for name, group in stratum_groups:
                N_h = len(group)
                
                if N_h == 0:
                    continue
                
                # Dynamic risk formula: Risk_h = ln(N_h) Ã— frequency Ã— 100
                freq = N_h / total_pop
                risk_h = math.log(max(N_h, 1)) * freq * 100
                
                data.loc[group.index, 'risk_score'] = risk_h
            
            # Verify all records have risk_score
            if data['risk_score'].isna().sum() > 0:
                data['risk_score'].fillna(0.0, inplace=True)
            
            return data
            
        except Exception as e:
            raise Exception(f"Error calculating risk scores: {str(e)}")
    
    def risk_stratified_pps_sampling(self, data, target_size):
        """Risk-stratified PPS sampling with two-phase allocation"""
        target_size = int(target_size)
        data = data.copy()
        
        stratum_groups = data.groupby(self.stratum_columns, observed=True)
        total_pop = len(data)
        
        stratum_allocations = {}
        total_reserved = 0
        total_weight_large = 0
        
        for name, group in stratum_groups:
            N_h = len(group)
            
            if N_h < 10:  # Small stratum threshold
                stratum_allocations[name] = {
                    'population': N_h,
                    'is_small': True,
                    'allocated': 1,
                    'group': group.copy(),
                    'reason': f'Reserved (small stratum N={N_h})',
                    'risk_score': 0.0
                }
                total_reserved += 1
            else:
                # Large stratum: calculate risk weight
                freq = N_h / total_pop
                risk_h = math.log(max(N_h, 1)) * freq * 100
                weight = N_h * risk_h
                
                stratum_allocations[name] = {
                    'population': N_h,
                    'risk_score': risk_h,
                    'is_small': False,
                    'weight': weight,
                    'group': group.copy(),
                    'reason': 'Risk-weighted allocation',
                    'allocated': 0
                }
                total_weight_large += weight
        
        remaining_budget = target_size - total_reserved
        
        for name, info in stratum_allocations.items():
            if info['is_small']:
                continue
            
            if total_weight_large > 0:
                n_h = max(0, int((info['weight'] / total_weight_large) * remaining_budget))
            else:
                n_h = 0
            
            n_h = min(n_h, info['population'])
            info['allocated'] = n_h
        
        total_allocated = sum(info['allocated'] for info in stratum_allocations.values())
        
        if total_allocated < target_size:
            diff = target_size - total_allocated
            sorted_strata = sorted(
                [(name, info) for name, info in stratum_allocations.items() 
                 if not info['is_small']],
                key=lambda x: x[1]['weight'],
                reverse=True
            )
            
            for name, info in sorted_strata:
                if diff <= 0:
                    break
                can_add = min(diff, info['population'] - info['allocated'])
                info['allocated'] += can_add
                diff -= can_add
        
        elif total_allocated > target_size:
            diff = total_allocated - target_size
            sorted_strata = sorted(
                [(name, info) for name, info in stratum_allocations.items() 
                 if not info['is_small']],
                key=lambda x: x[1]['weight'],
                reverse=False
            )
            
            for name, info in sorted_strata:
                if diff <= 0:
                    break
                can_remove = min(diff, max(0, info['allocated'] - 1))
                info['allocated'] -= can_remove
                diff -= can_remove
        
        samples = []
        
        for name, info in stratum_allocations.items():
            group = info['group']
            sample_size_h = info['allocated']
            
            if sample_size_h > 0 and len(group) > 0:
                if sample_size_h >= len(group):
                    samples.append(group)
                else:
                    if info['is_small']:
                        stratum_sample = group.sample(n=1, random_state=42)
                    else:
                        high_risk_count = max(1, int(sample_size_h * 0.4))
                        group_sorted = group.sort_values('risk_score', ascending=False)
                        high_risk_sample = group_sorted.head(high_risk_count)
                        remaining = sample_size_h - len(high_risk_sample)
                        
                        if remaining > 0:
                            remaining_data = group[~group.index.isin(high_risk_sample.index)]
                            if len(remaining_data) > 0:
                                random_sample = remaining_data.sample(
                                    n=min(remaining, len(remaining_data)),
                                    random_state=42
                                )
                                stratum_sample = pd.concat([high_risk_sample, random_sample])
                            else:
                                stratum_sample = high_risk_sample
                        else:
                            stratum_sample = high_risk_sample
                    
                    if len(stratum_sample) > 0:
                        samples.append(stratum_sample)
        
        if samples:
            final_sample = pd.concat(samples).drop_duplicates()
            sample = final_sample.head(target_size).copy()
        else:
            sample = data.sample(n=min(target_size, len(data)), random_state=42)
        
        self.stratum_allocations = stratum_allocations
        return sample
    
    def traditional_random_sampling(self, data, target_size):
        """Pure random sampling"""
        return data.sample(n=min(int(target_size), len(data)), random_state=42)
    
    def hybrid_pps_anomaly_sampling(self, data, target_size):
        """
        Hybrid approach: 70% Risk-PPS + 20% Anomalies + 10% Random
        FIX: Robust numeric coercion for anomaly detection
        """
        data = data.copy()
        target_size = int(target_size)
        
        pps_size = int(target_size * 0.70)
        anomaly_size = int(target_size * 0.20)
        random_size = target_size - pps_size - anomaly_size
        
        pps_sample = self.risk_stratified_pps_sampling(data, pps_size)
        remaining_data = data[~data.index.isin(pps_sample.index)]
        
        if len(remaining_data) > 0 and anomaly_size > 0:
            try:
                # FIX: Robust numeric column detection with coercion
                numeric_cols = []
                for col in data.columns:
                    try:
                        converted = pd.to_numeric(remaining_data[col], errors='coerce')
                        if converted.notna().sum() > 0:
                            numeric_cols.append(col)
                    except:
                        pass
                
                if len(numeric_cols) > 0:
                    # FIX: Convert ALL values to numeric before passing to IsolationForest
                    X = remaining_data[numeric_cols].apply(pd.to_numeric, errors='coerce').fillna(0).values
                    
                    # Only proceed if we have valid numeric data
                    if X.shape[0] > 0 and X.shape[1] > 0:
                        iso_forest = IsolationForest(contamination=0.1, random_state=42)
                        anomaly_scores = iso_forest.fit_predict(X)
                        anomaly_indices = remaining_data.index[anomaly_scores == -1]
                        
                        if len(anomaly_indices) > 0:
                            anomaly_sample = remaining_data.loc[anomaly_indices[:anomaly_size]]
                        else:
                            anomaly_sample = remaining_data.sample(
                                n=min(anomaly_size, len(remaining_data)),
                                random_state=42
                            )
                    else:
                        anomaly_sample = remaining_data.sample(
                            n=min(anomaly_size, len(remaining_data)),
                            random_state=42
                        )
                else:
                    anomaly_sample = remaining_data.sample(
                        n=min(anomaly_size, len(remaining_data)),
                        random_state=42
                    )
            except Exception as e:
                # Fallback: use random sampling if anomaly detection fails
                anomaly_sample = remaining_data.sample(
                    n=min(anomaly_size, len(remaining_data)),
                    random_state=42
                )
        else:
            anomaly_sample = pd.DataFrame()
        
        remaining_data2 = data[~data.index.isin(
            pd.concat([pps_sample, anomaly_sample]).index
        )]
        
        if len(remaining_data2) > 0 and random_size > 0:
            random_sample = remaining_data2.sample(
                n=min(random_size, len(remaining_data2)),
                random_state=42
            )
        else:
            random_sample = pd.DataFrame()
        
        hybrid_sample = pd.concat([pps_sample, anomaly_sample, random_sample])
        return hybrid_sample.head(target_size)
    
    def analyze_coverage(self, data, sample):
        """Analyze sample coverage across strata"""
        stratum_groups = data.groupby(self.stratum_columns, observed=True)
        sample_groups = sample.groupby(self.stratum_columns, observed=True)
        
        total_strata = len(stratum_groups)
        covered_strata = len(sample_groups)
        coverage_pct = (covered_strata / total_strata * 100) if total_strata > 0 else 0
        
        data_strata = set(stratum_groups.groups.keys())
        sample_strata = set(sample_groups.groups.keys())
        missed_strata = data_strata - sample_strata
        
        return {
            'total_strata': total_strata,
            'covered_strata': covered_strata,
            'coverage_pct': coverage_pct,
            'missed_strata': missed_strata,
            'missed_count': len(missed_strata)
        }
    
    def export_results(self, samples_dict, data):
        """Export all results to CSV files"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        exported_files = []
        
        try:
            for method, sample in samples_dict.items():
                sample_file = f"{self.results_dir}/Sample_{method}_{timestamp}.csv"
                sample.to_csv(sample_file, index=False)
                exported_files.append(sample_file)
                
                out_of_scope = data[~data.index.isin(sample.index)]
                oos_file = f"{self.results_dir}/OutOfScope_{method}_{timestamp}.csv"
                out_of_scope.to_csv(oos_file, index=False)
                exported_files.append(oos_file)
            
            return exported_files
        except Exception as e:
            raise Exception(f"Export failed: {str(e)}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GUI APPLICATION - SIMPLIFIED 4-TAB VERSION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class OMRCGUIApplication:
    """GUI Application for OMRC Risk-Based Sampling Tool - Simplified"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("OMRC Risk-Based Sampling Tool v4.0")
        self.root.geometry("1500x900")
        
        self.app = OMRCRiskBasedSampling()
        self.data = None
        self.selected_additional_columns = []
        
        self.setup_ui()
    
    def setup_ui(self):
        """Setup 4 main tabs"""
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Tab 1: Load & Configure
        self.tab1 = ttk.Frame(self.notebook)
        self.notebook.add(self.tab1, text="1ï¸âƒ£  Load & Configure")
        self.setup_tab1()
        
        # Tab 2: Analyze
        self.tab2 = ttk.Frame(self.notebook)
        self.notebook.add(self.tab2, text="2ï¸âƒ£  Analyze")
        self.setup_tab2()
        
        # Tab 3: Sample & Compare
        self.tab3 = ttk.Frame(self.notebook)
        self.notebook.add(self.tab3, text="3ï¸âƒ£  Sample & Compare")
        self.setup_tab3()
        
        # Tab 4: Export & Results
        self.tab4 = ttk.Frame(self.notebook)
        self.notebook.add(self.tab4, text="4ï¸âƒ£  Export & Results")
        self.setup_tab4()
    
    def setup_tab1(self):
        """Tab 1: Data Loading and Column Selection"""
        main_frame = ttk.Frame(self.tab1)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # SECTION 1: DATA LOADING
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        loading_frame = ttk.LabelFrame(main_frame, text="ğŸ“ Step 1: Load Data", padding=10)
        loading_frame.pack(fill='x', pady=(0, 10))
        
        button_frame = ttk.Frame(loading_frame)
        button_frame.pack(fill='x', pady=5)
        
        ttk.Button(button_frame, text="ğŸ“‚ Load CSV/Excel File", 
                  command=self.load_data).pack(side='left', padx=5)
        ttk.Button(button_frame, text="ğŸ² Generate Sample Data", 
                  command=self.generate_sample_data).pack(side='left', padx=5)
        
        self.data_info_label = ttk.Label(loading_frame, text="â³ No data loaded", 
                                         font=('Arial', 11, 'bold'), foreground='red')
        self.data_info_label.pack(side='left', padx=20)
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # SECTION 2: COLUMN SELECTION
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        column_frame = ttk.LabelFrame(main_frame, text="ğŸ” Step 2: Select Stratification Columns", padding=10)
        column_frame.pack(fill='x', pady=5)
        
        # Grid layout for 3 mandatory columns
        grid_frame = ttk.Frame(column_frame)
        grid_frame.pack(fill='x', pady=5)
        
        ttk.Label(grid_frame, text="Column 1:*", font=('Arial', 9, 'bold')).grid(row=0, column=0, sticky='w', padx=5)
        self.col1_var = tk.StringVar(value="")
        self.col1_combo = ttk.Combobox(grid_frame, textvariable=self.col1_var, width=22, state='readonly')
        self.col1_combo.grid(row=0, column=1, padx=5, sticky='w')
        
        ttk.Label(grid_frame, text="Column 2:*", font=('Arial', 9, 'bold')).grid(row=0, column=2, sticky='w', padx=(20, 5))
        self.col2_var = tk.StringVar(value="")
        self.col2_combo = ttk.Combobox(grid_frame, textvariable=self.col2_var, width=22, state='readonly')
        self.col2_combo.grid(row=0, column=3, padx=5, sticky='w')
        
        ttk.Label(grid_frame, text="Column 3:*", font=('Arial', 9, 'bold')).grid(row=1, column=0, sticky='w', padx=5, pady=(5, 0))
        self.col3_var = tk.StringVar(value="")
        self.col3_combo = ttk.Combobox(grid_frame, textvariable=self.col3_var, width=22, state='readonly')
        self.col3_combo.grid(row=1, column=1, padx=5, sticky='w', pady=(5, 0))
        
        # Validation Status
        self.column_status = ttk.Label(column_frame, text="âš ï¸  Select all 3 mandatory columns", 
                                       foreground='red', font=('Arial', 10, 'bold'))
        self.column_status.pack(pady=10)
        
        # Additional Columns
        additional_frame = ttk.Frame(column_frame)
        additional_frame.pack(fill='x', pady=5)
        
        self.additional_cols_label = ttk.Label(additional_frame, text="ğŸ“Œ Additional: None selected", foreground='gray')
        self.additional_cols_label.pack(anchor='w', pady=3)
        
        ttk.Button(additional_frame, text="â• Add Optional Columns", 
                  command=self.open_column_selector).pack(anchor='w', pady=3)
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # SECTION 3: DATA PREVIEW
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        preview_frame = ttk.LabelFrame(main_frame, text="ğŸ“‹ Data Preview (First 50 Rows)", padding=10)
        preview_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        tree_frame = ttk.Frame(preview_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True)
        
        scrollbar_y = ttk.Scrollbar(tree_frame, orient="vertical")
        scrollbar_x = ttk.Scrollbar(tree_frame, orient="horizontal")
        
        self.tree = ttk.Treeview(tree_frame, yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        scrollbar_y.config(command=self.tree.yview)
        scrollbar_x.config(command=self.tree.xview)
        
        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
        scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        tree_frame.rowconfigure(0, weight=1)
        tree_frame.columnconfigure(0, weight=1)
    
    def setup_tab2(self):
        """Tab 2: Risk Analysis & Coverage"""
        main_frame = ttk.Frame(self.tab2)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Button frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill='x', pady=(0, 10))
        
        ttk.Button(button_frame, text="ğŸ”¬ Calculate Risk Scores", 
                  command=self.calculate_risk).pack(side='left', padx=5, pady=5)
        
        # Notebook for analysis and coverage
        analysis_notebook = ttk.Notebook(main_frame)
        analysis_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Risk Analysis tab
        risk_frame = ttk.Frame(analysis_notebook)
        analysis_notebook.add(risk_frame, text="Risk Analysis")
        
        self.risk_text = tk.Text(risk_frame, height=30, width=150, font=('Courier', 9))
        self.risk_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Coverage Analysis tab
        coverage_frame = ttk.Frame(analysis_notebook)
        analysis_notebook.add(coverage_frame, text="Coverage Summary")
        
        self.coverage_text = tk.Text(coverage_frame, height=30, width=150, font=('Courier', 9))
        self.coverage_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    def setup_tab3(self):
        """Tab 3: Sampling Methods & Visualizations"""
        main_frame = ttk.Frame(self.tab3)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PARAMETERS FRAME
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        param_frame = ttk.LabelFrame(main_frame, text="âš™ï¸  Sampling Parameters", padding=10)
        param_frame.pack(fill='x', pady=(0, 10))
        
        # Parameters in grid
        grid = ttk.Frame(param_frame)
        grid.pack(fill='x')
        
        ttk.Label(grid, text="Confidence Level (%):").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.confidence_var = tk.DoubleVar(value=95)
        ttk.Spinbox(grid, from_=80, to=99, textvariable=self.confidence_var, width=10).grid(row=0, column=1, padx=5, sticky='w')
        
        ttk.Label(grid, text="Margin of Error:").grid(row=0, column=2, sticky='w', padx=(20, 5), pady=5)
        self.margin_var = tk.DoubleVar(value=0.05)
        ttk.Spinbox(grid, from_=0.01, to=0.20, increment=0.01, textvariable=self.margin_var, width=10).grid(row=0, column=3, padx=5, sticky='w')
        
        ttk.Label(grid, text="Error Rate:").grid(row=0, column=4, sticky='w', padx=(20, 5), pady=5)
        self.error_var = tk.DoubleVar(value=0.15)
        ttk.Spinbox(grid, from_=0.01, to=0.50, increment=0.01, textvariable=self.error_var, width=10).grid(row=0, column=5, padx=5, sticky='w')
        
        # Methods selection
        methods_frame = ttk.LabelFrame(param_frame, text="ğŸ¯ Select Sampling Methods", padding=10)
        methods_frame.pack(fill='x', pady=10)
        
        self.traditional_var = tk.BooleanVar(value=True)
        self.risk_pps_var = tk.BooleanVar(value=True)
        self.hybrid_var = tk.BooleanVar(value=False)
        
        ttk.Checkbutton(methods_frame, text="âœ“ Traditional Random Sampling", 
                       variable=self.traditional_var).pack(anchor='w', padx=10, pady=3)
        ttk.Checkbutton(methods_frame, text="âœ“ Risk-Stratified PPS (Recommended)", 
                       variable=self.risk_pps_var).pack(anchor='w', padx=10, pady=3)
        ttk.Checkbutton(methods_frame, text="âœ“ Hybrid (PPS + Anomalies)", 
                       variable=self.hybrid_var).pack(anchor='w', padx=10, pady=3)
        
        # Generate button
        ttk.Button(param_frame, text="â–¶ï¸  Generate & Compare Samples", 
                  command=self.generate_samples).pack(pady=10)
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # RESULTS NOTEBOOK
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        results_notebook = ttk.Notebook(main_frame)
        results_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Sampling Results tab
        sampling_frame = ttk.Frame(results_notebook)
        results_notebook.add(sampling_frame, text="Sampling Results")
        
        self.sampling_text = tk.Text(sampling_frame, height=25, width=150, font=('Courier', 9))
        self.sampling_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Stratum Report tab
        stratum_frame = ttk.Frame(results_notebook)
        results_notebook.add(stratum_frame, text="Stratum Report")
        
        self.stratum_tree = ttk.Treeview(stratum_frame, height=20, columns=(
            'Stratum', 'Population', 'Risk Score', 'Allocated', 'Reason'
        ))
        self.stratum_tree.heading('#0', text='#')
        self.stratum_tree.heading('Stratum', text='Stratum')
        self.stratum_tree.heading('Population', text='Population')
        self.stratum_tree.heading('Risk Score', text='Risk Score')
        self.stratum_tree.heading('Allocated', text='Allocated')
        self.stratum_tree.heading('Reason', text='Allocation Reason')
        
        self.stratum_tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Charts tab
        charts_frame = ttk.Frame(results_notebook)
        results_notebook.add(charts_frame, text="Charts & Visualizations")
        
        button_frame = ttk.Frame(charts_frame)
        button_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Button(button_frame, text="ğŸ“Š Generate Charts", 
                  command=self.generate_charts).pack(side='left', padx=5)
        
        self.chart_frame = ttk.Frame(charts_frame)
        self.chart_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    def setup_tab4(self):
        """Tab 4: Export & Detailed Results"""
        main_frame = ttk.Frame(self.tab4)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Export buttons frame
        export_button_frame = ttk.LabelFrame(main_frame, text="ğŸ’¾ Export Options", padding=10)
        export_button_frame.pack(fill='x', pady=(0, 10))
        
        ttk.Button(export_button_frame, text="ğŸ“¥ Export All Results", 
                  command=self.export_all_results).pack(side='left', padx=5, pady=5)
        ttk.Button(export_button_frame, text="ğŸ“¥ Export Traditional", 
                  command=lambda: self.export_single_method('Traditional_Random')).pack(side='left', padx=5, pady=5)
        ttk.Button(export_button_frame, text="ğŸ“¥ Export Risk-PPS", 
                  command=lambda: self.export_single_method('Risk_PPS')).pack(side='left', padx=5, pady=5)
        ttk.Button(export_button_frame, text="ğŸ“¥ Export Hybrid", 
                  command=lambda: self.export_single_method('Hybrid')).pack(side='left', padx=5, pady=5)
        
        # Results notebook
        results_notebook = ttk.Notebook(main_frame)
        results_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Export status tab
        export_frame = ttk.Frame(results_notebook)
        results_notebook.add(export_frame, text="Export Status")
        
        self.export_text = tk.Text(export_frame, height=25, width=150, font=('Courier', 9))
        self.export_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Covered Strata tab
        covered_frame = ttk.Frame(results_notebook)
        results_notebook.add(covered_frame, text="Covered Strata")
        
        self.covered_text = tk.Text(covered_frame, height=25, width=150, font=('Courier', 9))
        self.covered_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Missed Strata tab
        missed_frame = ttk.Frame(results_notebook)
        results_notebook.add(missed_frame, text="Missed Strata")
        
        self.missed_text = tk.Text(missed_frame, height=25, width=150, font=('Courier', 9))
        self.missed_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # CALLBACKS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    def load_data(self):
        """Load data from CSV or Excel"""
        file_path = filedialog.askopenfilename(
            filetypes=[("CSV", "*.csv"), ("Excel", "*.xlsx")]
        )
        if file_path:
            try:
                self.data = pd.read_csv(file_path) if file_path.endswith('.csv') \
                           else pd.read_excel(file_path)
                
                # FIX: Coerce numeric columns
                self.data = self.app.coerce_numeric_columns(self.data)
                self.app.data = self.data
                
                self.update_column_dropdowns()
                self.update_data_preview()
                
                self.data_info_label.config(
                    text=f"âœ… Loaded: {len(self.data):,} records | {len(self.data.columns)} columns",
                    foreground='green'
                )
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load data: {str(e)}")
    
    def generate_sample_data(self):
        """Generate sample data for testing"""
        np.random.seed(42)
        
        entities = ['HBAP', 'HBUS', 'GFX', 'IRD', 'GBM']
        regions = ['LN', 'NY', 'SG', 'HK', 'TYO']
        products = ['Equities', 'FX', 'Rates', 'Credit', 'Commodities']
        
        data = []
        for _ in range(183823):
            data.append({
                'Entity': np.random.choice(entities),
                'Region': np.random.choice(regions),
                'Product': np.random.choice(products),
                'Value': np.random.uniform(1000, 1000000),
                'Aging': np.random.randint(1, 365),
                'Status': np.random.choice(['Active', 'Pending', 'Exception'])
            })
        
        self.data = pd.DataFrame(data)
        self.app.data = self.data
        
        self.update_column_dropdowns()
        self.update_data_preview()
        
        self.col1_var.set("Entity")
        self.col2_var.set("Region")
        self.col3_var.set("Product")
        
        total_strata = len(self.data.groupby(['Entity', 'Region', 'Product']))
        
        self.data_info_label.config(
            text=f"âœ… Generated: {len(self.data):,} records | {total_strata:,} strata",
            foreground='green'
        )
    
    def update_column_dropdowns(self):
        """Update dropdown options"""
        if self.data is None:
            return
        
        columns = [""] + list(self.data.columns)
        self.col1_combo['values'] = columns
        self.col2_combo['values'] = columns
        self.col3_combo['values'] = columns
    
    def update_data_preview(self):
        """Update data preview"""
        if self.data is None:
            return
        
        for item in self.tree.get_children():
            self.tree.delete(item)
        
        display_cols = list(self.data.columns)[:10]
        
        self.tree["columns"] = display_cols
        self.tree["show"] = "headings"
        
        for col in display_cols:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=120, anchor='center')
        
        for idx, (_, row) in enumerate(self.data.head(50).iterrows()):
            values = [str(row[col])[:50] for col in display_cols]
            self.tree.insert("", "end", values=values)
    
    def open_column_selector(self):
        """Open column selector dialog"""
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        mandatory_cols = [col for col in [self.col1_var.get(), self.col2_var.get(), self.col3_var.get()]
                         if col.strip() != ""]
        available_cols = [col for col in self.data.columns if col not in mandatory_cols]
        
        dialog = Toplevel(self.root)
        dialog.title("Select Additional Columns")
        dialog.geometry("500x400")
        
        ttk.Label(dialog, text="Select additional columns (Ctrl+Click for multiple):", 
                 font=('Arial', 10, 'bold')).pack(pady=10)
        
        frame = ttk.Frame(dialog)
        frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        scrollbar = ttk.Scrollbar(frame)
        scrollbar.pack(side='right', fill='y')
        
        listbox = Listbox(frame, selectmode=MULTIPLE, yscrollcommand=scrollbar.set, font=('Arial', 10))
        listbox.pack(side='left', fill='both', expand=True)
        scrollbar.config(command=listbox.yview)
        
        for col in available_cols:
            listbox.insert('end', col)
        
        for i, col in enumerate(available_cols):
            if col in self.selected_additional_columns:
                listbox.selection_set(i)
        
        def confirm():
            selected = listbox.curselection()
            self.selected_additional_columns = [available_cols[i] for i in selected]
            
            if self.selected_additional_columns:
                preview = ', '.join(self.selected_additional_columns[:2])
                if len(self.selected_additional_columns) > 2:
                    preview += '...'
                self.additional_cols_label.config(
                    text=f"ğŸ“Œ Additional: {len(self.selected_additional_columns)} selected ({preview})",
                    foreground='blue'
                )
            else:
                self.additional_cols_label.config(text="ğŸ“Œ Additional: None selected", foreground='gray')
            dialog.destroy()
        
        ttk.Button(dialog, text="âœ… Confirm", command=confirm).pack(pady=10)
    
    def validate_mandatory_columns(self):
        """Validate column selection"""
        col1_sel = self.col1_var.get().strip()
        col2_sel = self.col2_var.get().strip()
        col3_sel = self.col3_var.get().strip()
        
        all_selected = col1_sel != "" and col2_sel != "" and col3_sel != ""
        
        if all_selected and len({col1_sel, col2_sel, col3_sel}) != 3:
            self.column_status.config(text="âš ï¸  All columns must be different!", foreground='red')
            return False
        
        if all_selected:
            self.column_status.config(text="âœ… All mandatory columns selected", foreground='green')
        else:
            self.column_status.config(text="âš ï¸  Select all 3 mandatory columns", foreground='red')
        
        return all_selected
    
    def update_stratum_columns(self):
        """Update stratum columns"""
        cols = [self.col1_var.get(), self.col2_var.get(), self.col3_var.get()]
        cols = [c for c in cols if c.strip() != ""]
        cols.extend(self.selected_additional_columns)
        self.app.stratum_columns = cols
    
    def calculate_risk(self):
        """Calculate risk scores"""
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        if not self.validate_mandatory_columns():
            messagebox.showerror("Error", "Select all 3 mandatory columns")
            return
        
        self.update_stratum_columns()
        
        try:
            self.risk_text.delete('1.0', tk.END)
            
            data_with_risk = self.app.calculate_dynamic_risk_scores(self.data, self.app.stratum_columns)
            self.data = data_with_risk
            self.app.data = data_with_risk
            
            stratum_groups = data_with_risk.groupby(self.app.stratum_columns, observed=True)
            total_strata = len(stratum_groups)
            small_strata = sum(1 for name, group in stratum_groups if len(group) < 10)
            large_strata = total_strata - small_strata
            
            output = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                     DYNAMIC RISK ANALYSIS RESULTS                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

POPULATION INSIGHTS:
  Total Records: {len(data_with_risk):,}
  Total Strata: {total_strata:,}
  Small Strata (N < 10): {small_strata:,}
  Large Strata (N >= 10): {large_strata:,}

PHASE 1 (Identification):
  âœ“ Small strata identified: {small_strata:,}
  âœ“ Samples to reserve: {small_strata:,} (1 per stratum)

PHASE 2 (Risk-Weight Allocation):
  âœ“ Large strata identified: {large_strata:,}
  âœ“ Remaining budget: {max(0, 1247 - small_strata):,} samples

RISK SCORE FORMULA:
  Risk_h = ln(N_h) Ã— (N_h / Total_Pop) Ã— 100

TOP 10 HIGHEST RISK STRATA:
"""
            
            stratum_risks = []
            for name, group in stratum_groups:
                risk_score = group['risk_score'].iloc[0] if len(group) > 0 else 0
                stratum_risks.append((name, len(group), risk_score))
            
            stratum_risks.sort(key=lambda x: x[2], reverse=True)
            
            for i, (name, pop, risk) in enumerate(stratum_risks[:10], 1):
                output += f"\n{i:2d}. {str(name)[:40]:40s} | Pop: {pop:6d} | Risk: {risk:8.2f}"
            
            output += f"\n\nâœ“ Risk scores calculated for all {len(data_with_risk):,} records"
            
            self.risk_text.insert('1.0', output)
            
        except Exception as e:
            messagebox.showerror("Error", f"Risk calculation failed: {str(e)}")
    
    def generate_samples(self):
        """Generate samples"""
        if self.data is None:
            messagebox.showerror("Error", "Calculate risk scores first")
            return
        
        try:
            confidence = self.confidence_var.get() / 100
            margin = self.margin_var.get()
            error_rate = self.error_var.get()
            z_score = 1.96 if confidence == 0.95 else 2.576
            n = int(((z_score ** 2) * error_rate * (1 - error_rate)) / (margin ** 2))
            
            self.sampling_text.delete('1.0', tk.END)
            
            output = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    SAMPLING RESULTS COMPARISON                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SAMPLE SIZE (Cochran Formula):
  Confidence: {self.confidence_var.get()}% | Margin: {margin} | Error Rate: {error_rate}
  Z-Score: {z_score} | Sample Size: {n:,} records

{'â”€' * 79}
"""
            
            samples_dict = {}
            coverage_dict = {}
            
            if self.traditional_var.get():
                trad_sample = self.app.traditional_random_sampling(self.data, n)
                samples_dict['Traditional_Random'] = trad_sample
                coverage = self.app.analyze_coverage(self.data, trad_sample)
                coverage_dict['Traditional_Random'] = coverage
                
                output += f"""
TRADITIONAL RANDOM:
  Size: {len(trad_sample):,} | Covered: {coverage['covered_strata']:,}/{coverage['total_strata']:,} | Coverage: {coverage['coverage_pct']:.1f}%
"""
            
            if self.risk_pps_var.get():
                pps_sample = self.app.risk_stratified_pps_sampling(self.data, n)
                samples_dict['Risk_PPS'] = pps_sample
                coverage = self.app.analyze_coverage(self.data, pps_sample)
                coverage_dict['Risk_PPS'] = coverage
                
                output += f"""
RISK-STRATIFIED PPS (RECOMMENDED):
  Size: {len(pps_sample):,} | Covered: {coverage['covered_strata']:,}/{coverage['total_strata']:,} | Coverage: {coverage['coverage_pct']:.1f}%
  âœ“ Phase 1 small strata reserved | Phase 2 risk-weighted allocation
"""
            
            if self.hybrid_var.get():
                hybrid_sample = self.app.hybrid_pps_anomaly_sampling(self.data, int(n * 1.3))
                samples_dict['Hybrid'] = hybrid_sample
                coverage = self.app.analyze_coverage(self.data, hybrid_sample)
                coverage_dict['Hybrid'] = coverage
                
                output += f"""
HYBRID (PPS + ANOMALIES):
  Size: {len(hybrid_sample):,} (+30%) | Covered: {coverage['covered_strata']:,}/{coverage['total_strata']:,} | Coverage: {coverage['coverage_pct']:.1f}%
  Composition: 70% Risk-PPS + 20% Anomalies + 10% Random
"""
            
            output += f"\n{'â”€' * 79}\nâœ“ Samples generated successfully\n"
            
            self.sampling_text.insert('1.0', output)
            
            self.samples_dict = samples_dict
            self.coverage_dict = coverage_dict
            
            self.show_stratum_report()
            self.show_covered_missed_strata()
            self.show_coverage_analysis()
            
        except Exception as e:
            messagebox.showerror("Error", f"Sampling failed: {str(e)}")
    
    def show_stratum_report(self):
        """Show stratum report"""
        if not hasattr(self, 'samples_dict') or 'Risk_PPS' not in self.samples_dict:
            return
        
        for item in self.stratum_tree.get_children():
            self.stratum_tree.delete(item)
        
        stratum_allocations = self.app.stratum_allocations
        
        for i, (name, info) in enumerate(sorted(stratum_allocations.items()), 1):
            self.stratum_tree.insert('', 'end', text=str(i),
                values=(str(name)[:40], info['population'], f"{info['risk_score']:.2f}", 
                        info['allocated'], info['reason'][:50]))
    
    def show_covered_missed_strata(self):
        """Show covered/missed strata"""
        if not hasattr(self, 'samples_dict'):
            return
        
        self.covered_text.delete('1.0', tk.END)
        covered_output = "\nCOVERED STRATA:\n" + "â”€" * 80 + "\n"
        
        for method, sample in self.samples_dict.items():
            sample_groups = sample.groupby(self.app.stratum_columns, observed=True)
            covered_output += f"\n{method}:\n"
            for i, (name, group) in enumerate(sorted(sample_groups.groups.items()), 1):
                covered_output += f"{i:3d}. {str(name)[:60]:60s} | Count: {len(group):6d}\n"
        
        self.covered_text.insert('1.0', covered_output)
        
        self.missed_text.delete('1.0', tk.END)
        missed_output = "\nMISSED STRATA:\n" + "â”€" * 80 + "\n"
        
        data_strata = set(self.data.groupby(self.app.stratum_columns, observed=True).groups.keys())
        
        for method, sample in self.samples_dict.items():
            sample_strata = set(sample.groupby(self.app.stratum_columns, observed=True).groups.keys())
            missed_strata = data_strata - sample_strata
            
            missed_output += f"\n{method}:\n"
            if missed_strata:
                for i, stratum in enumerate(sorted(missed_strata), 1):
                    pop = len(self.data[self.data[self.app.stratum_columns].apply(tuple, axis=1) == stratum])
                    missed_output += f"{i:3d}. {str(stratum)[:60]:60s} | Population: {pop:6d}\n"
            else:
                missed_output += "âœ“ NO MISSED STRATA - 100% Coverage!\n"
        
        self.missed_text.insert('1.0', missed_output)
    
    def show_coverage_analysis(self):
        """Show coverage analysis"""
        if not hasattr(self, 'coverage_dict'):
            return
        
        self.coverage_text.delete('1.0', tk.END)
        
        output = "\nCOVERAGE ANALYSIS:\n" + "â•" * 80 + "\n"
        
        for method, coverage in self.coverage_dict.items():
            output += f"""
{method}:
  Total Strata: {coverage['total_strata']:>10,} | Covered: {coverage['covered_strata']:>10,}
  Missed: {coverage['missed_count']:>10,} | Coverage Rate: {coverage['coverage_pct']:>10.1f}%
"""
        
        self.coverage_text.insert('1.0', output)
    
    def generate_charts(self):
        """Generate charts"""
        if not hasattr(self, 'samples_dict'):
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            for widget in self.chart_frame.winfo_children():
                widget.destroy()
            
            fig, axes = plt.subplots(2, 2, figsize=(14, 10))
            fig.suptitle('OMRC Sampling Methods Comparison', fontsize=14, fontweight='bold')
            
            methods = list(self.samples_dict.keys())
            sample_sizes = [len(self.samples_dict[m]) for m in methods]
            coverages = [self.coverage_dict[m]['coverage_pct'] for m in methods]
            
            colors = ['#3498db', '#2ecc71', '#f39c12'][:len(methods)]
            
            # Chart 1
            axes[0, 0].bar(methods, sample_sizes, color=colors)
            axes[0, 0].set_title('Sample Sizes', fontweight='bold')
            axes[0, 0].set_ylabel('Count')
            for i, v in enumerate(sample_sizes):
                axes[0, 0].text(i, v + 50, str(v), ha='center', fontweight='bold')
            
            # Chart 2
            axes[0, 1].bar(methods, coverages, color=colors)
            axes[0, 1].set_title('Strata Coverage %', fontweight='bold')
            axes[0, 1].set_ylabel('Coverage %')
            axes[0, 1].set_ylim(0, 100)
            for i, v in enumerate(coverages):
                axes[0, 1].text(i, v + 2, f'{v:.1f}%', ha='center', fontweight='bold')
            
            # Chart 3
            if 'Risk_PPS' in self.samples_dict and 'risk_score' in self.data.columns:
                axes[1, 0].hist(self.data['risk_score'], bins=50, color='#2ecc71', edgecolor='black', alpha=0.7)
                axes[1, 0].set_title('Risk Score Distribution', fontweight='bold')
                axes[1, 0].set_xlabel('Risk Score')
                axes[1, 0].set_ylabel('Frequency')
            
            # Chart 4
            covered = [self.coverage_dict[m]['covered_strata'] for m in methods]
            missed = [self.coverage_dict[m]['missed_count'] for m in methods]
            x = np.arange(len(methods))
            width = 0.35
            
            axes[1, 1].bar(x - width/2, covered, width, label='Covered', color='#2ecc71', alpha=0.8)
            axes[1, 1].bar(x + width/2, missed, width, label='Missed', color='#e74c3c', alpha=0.8)
            axes[1, 1].set_title('Strata Coverage', fontweight='bold')
            axes[1, 1].set_ylabel('Count')
            axes[1, 1].set_xticks(x)
            axes[1, 1].set_xticklabels(methods)
            axes[1, 1].legend()
            
            plt.tight_layout()
            
            canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
            canvas.draw()
            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except Exception as e:
            messagebox.showerror("Error", f"Chart generation failed: {str(e)}")
    
    def export_all_results(self):
        """Export all results"""
        if not hasattr(self, 'samples_dict'):
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            exported_files = self.app.export_results(self.samples_dict, self.data)
            
            self.export_text.delete('1.0', tk.END)
            output = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                      EXPORT RESULTS - SUCCESS âœ…                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Total Files: {len(exported_files)}
Location: {os.path.abspath(self.app.results_dir)}

Exported Files:
"""
            
            for f in exported_files:
                output += f"\n  âœ“ {f}"
            
            self.export_text.insert('1.0', output)
            messagebox.showinfo("Success", f"Exported {len(exported_files)} files!")
            
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")
    
    def export_single_method(self, method):
        """Export single method"""
        if not hasattr(self, 'samples_dict') or method not in self.samples_dict:
            messagebox.showerror("Error", f"{method} sample not available")
            return
        
        try:
            exported_files = self.app.export_results({method: self.samples_dict[method]}, self.data)
            
            self.export_text.delete('1.0', tk.END)
            output = f"âœ… Exported {method} results ({len(exported_files)} files)\n\nFiles:\n"
            for f in exported_files:
                output += f"  âœ“ {f}\n"
            
            self.export_text.insert('1.0', output)
            messagebox.showinfo("Success", f"Exported {method} successfully!")
            
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    root = tk.Tk()
    app = OMRCGUIApplication(root)
    root.mainloop()
