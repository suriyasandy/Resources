"""
OMRC Enhanced Multi-Dimensional Risk-Based Sampling Tool
Version 3.1 - FLEXIBLE COLUMN SELECTION FOR RISK FACTORS

Critical Improvements v3.1:
✓ NEW: Dynamic risk factor column selection from loaded data
✓ NEW: User can assign any numeric/categorical column to risk factors
✓ UPDATED: Tab 1 now includes "Select Risk Factor Columns" button
✓ UPDATED: Risk Calculation tab adapts to selected risk factor columns
✓ IMPROVED: Flexible, data-driven risk configuration
✓ MAINTAINED: All v3.0 methodology improvements

Mandatory Columns (User-Selected):
- Legal Entity
- Region
- Product

Risk Factor Columns (User-Selectable from Data):
- Value Risk (numeric, e.g., trade_value, amount)
- Aging Risk (numeric, e.g., aging_days, days_open)
- Reason Code Risk (categorical, e.g., reason_code, error_type)
- Additional Stratification (any columns)

Additional Stratification Columns:
- User can select ANY columns for multi-dimensional stratification

Methodology Standards:
- AICPA AS 2315 / AU-C 530
- ISA 530 (International Standard on Auditing)
- Stratified PPS (Probability Proportional to Size) sampling
- Cochran's Sample Size Formula
- Auxiliary variable based risk weighting
- Model-assisted survey sampling principles

Author: OMRC Compliance & Surveillance Technology
Version: 3.1 - Production Ready
Last Updated: December 9, 2025
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, Toplevel, Listbox, MULTIPLE, Scale, HORIZONTAL
import pandas as pd
import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler, MinMaxScaler
import math
from datetime import datetime
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette("husl")

class OMRCRiskBasedSamplingToolV3:
    
    def __init__(self, root):
        self.root = root
        self.root.title("OMRC Risk-Based Sampling v3.1 - Flexible Risk Factor Selection")
        self.root.geometry("1800x1100")
        self.root.configure(bg='#f0f0f0')
        
        # Data
        self.data = None
        self.comparison_results = {}
        self.out_of_scope_data = {}
        self.missed_strata = {}
        self.method_coverage_data = {}
        self.total_strata_count = 0
        self.stratum_analysis = {}
        
        # Risk configuration - now dynamic
        self.risk_config = {
            'value': {'weight': 0.25, 'enabled': False, 'column': None},
            'aging': {'weight': 0.15, 'enabled': False, 'column': None},
            'reason': {'weight': 0.10, 'enabled': False, 'column': None}
        }
        
        # Expert-assigned risk maps (customizable)
        self.expert_product_risk = {
            'IRD': 0.95,
            'FX_Derivatives': 0.90,
            'Equities': 0.75,
            'Structured_Products': 0.85,
            'ABS_MBS': 0.80,
            'Commodities': 0.70,
            'Repo': 0.50,
            'Cash_Bonds': 0.40
        }
        
        self.expert_reason_risk = {
            'Price_Mismatch': 0.95,
            'Model_Error': 0.85,
            'Data_Quality': 0.75,
            'System_Error': 0.80,
            'Manual_Override': 0.70,
            'Counterparty_Issue': 0.60,
            'Process_Delay': 0.40,
            'Settlement_Delay': 0.35
        }
        
        self.selected_additional_columns = []
        self.stratum_columns = []
        
        self.results_dir = os.path.join(os.getcwd(), "Results_v3")
        os.makedirs(self.results_dir, exist_ok=True)
        
        self.create_widgets()
    
    def safe_float_conversion(self, value, default=0.0):
        try:
            if isinstance(value, str):
                value = value.strip()
                if value == '': return default
            return float(value)
        except: return default
    
    def safe_int_conversion(self, value, default=0):
        try:
            if isinstance(value, str):
                value = value.strip()
                if value == '': return default
            return int(float(value))
        except: return default
    
    def ensure_numeric_column(self, df, column_name):
        if column_name in df.columns:
            df[column_name] = pd.to_numeric(df[column_name], errors='coerce')
        return df
    
    def safe_sort_unique(self, series):
        try:
            unique_vals = series.dropna().unique()
            try: return sorted(unique_vals)
            except: return sorted([str(val) for val in unique_vals])
        except: return list(series.dropna().unique())
    
    def create_widgets(self):
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        self.tab1 = ttk.Frame(notebook)
        notebook.add(self.tab1, text="1. Data & Config")
        
        self.tab2 = ttk.Frame(notebook)
        notebook.add(self.tab2, text="2. Risk Factors")
        
        self.tab3 = ttk.Frame(notebook)
        notebook.add(self.tab3, text="3. Sampling")
        
        self.tab4 = ttk.Frame(notebook)
        notebook.add(self.tab4, text="4. Coverage")
        
        self.tab5 = ttk.Frame(notebook)
        notebook.add(self.tab5, text="5. Stratum Report")
        
        self.tab6 = ttk.Frame(notebook)
        notebook.add(self.tab6, text="6. Visualizations")
        
        self.create_tab1_widgets()
        self.create_tab2_widgets()
        self.create_tab3_widgets()
        self.create_tab4_widgets()
        self.create_tab5_widgets()
        self.create_tab6_widgets()
    
    def create_tab1_widgets(self):
        """Tab 1: Data Loading & Configuration"""
        
        # Data Loading
        data_frame = ttk.LabelFrame(self.tab1, text="Data Loading", padding="10")
        data_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Button(data_frame, text="Load Data", command=self.load_data).grid(row=0, column=0, padx=5)
        ttk.Button(data_frame, text="Generate Sample", command=self.generate_sample_data).grid(row=0, column=1, padx=5)
        
        self.data_label = ttk.Label(data_frame, text="No data loaded", font=('Arial', 10, 'bold'), foreground='red')
        self.data_label.grid(row=1, column=0, columnspan=2, pady=5)
        
        # Mandatory Columns (3 columns: Entity, Region, Product)
        mandatory_frame = ttk.LabelFrame(self.tab1, text="MANDATORY COLUMNS (Fixed)", padding="10")
        mandatory_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Label(mandatory_frame, text="Legal Entity:*", font=('Arial', 9, 'bold')).grid(row=0, column=0, sticky=tk.W)
        self.entity_col_var = tk.StringVar(value="legal_entity")
        self.entity_col_combo = ttk.Combobox(mandatory_frame, textvariable=self.entity_col_var, width=25, state='readonly')
        self.entity_col_combo.grid(row=0, column=1, padx=5, sticky=tk.W)
        
        ttk.Label(mandatory_frame, text="Region:*", font=('Arial', 9, 'bold')).grid(row=0, column=2, sticky=tk.W, padx=(20,0))
        self.region_col_var = tk.StringVar(value="region")
        self.region_col_combo = ttk.Combobox(mandatory_frame, textvariable=self.region_col_var, width=25, state='readonly')
        self.region_col_combo.grid(row=0, column=3, padx=5, sticky=tk.W)
        
        ttk.Label(mandatory_frame, text="Product:*", font=('Arial', 9, 'bold')).grid(row=1, column=0, sticky=tk.W)
        self.product_col_var = tk.StringVar(value="product_type")
        self.product_col_combo = ttk.Combobox(mandatory_frame, textvariable=self.product_col_var, width=25, state='readonly')
        self.product_col_combo.grid(row=1, column=1, padx=5, sticky=tk.W)
        
        # Risk Factor Columns (Select from Data)
        risk_frame = ttk.LabelFrame(self.tab1, text="RISK FACTOR COLUMNS (Select from Data)", padding="10")
        risk_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Button(risk_frame, text="Select Risk Factor Columns", 
                  command=self.open_risk_factor_selector).grid(row=0, column=0, pady=5, sticky=tk.W)
        
        self.risk_factor_label = ttk.Label(risk_frame, text="None selected", foreground='gray', font=('Arial', 9))
        self.risk_factor_label.grid(row=0, column=1, sticky=tk.W, padx=20)
        
        # Additional Stratification Columns
        additional_frame = ttk.LabelFrame(self.tab1, text="ADDITIONAL STRATIFICATION COLUMNS", padding="10")
        additional_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        self.additional_cols_label = ttk.Label(additional_frame, text="None selected", foreground='gray')
        self.additional_cols_label.grid(row=0, column=0, sticky=tk.W, pady=5)
        
        ttk.Button(additional_frame, text="Select Stratification Columns", 
                  command=self.open_column_selector).grid(row=1, column=0, pady=5, sticky=tk.W)
        
        # Data Preview
        preview_frame = ttk.LabelFrame(self.tab1, text="Data Preview", padding="10")
        preview_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        self.tree = ttk.Treeview(preview_frame)
        scrollbar_y = ttk.Scrollbar(preview_frame, orient="vertical", command=self.tree.yview)
        scrollbar_x = ttk.Scrollbar(preview_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
        scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        self.tab1.rowconfigure(4, weight=1)
        self.tab1.columnconfigure(0, weight=1)
        preview_frame.rowconfigure(0, weight=1)
        preview_frame.columnconfigure(0, weight=1)
    
    def create_tab2_widgets(self):
        """Risk Factor Configuration Tab"""
        main_frame = ttk.Frame(self.tab2)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Weight configuration
        config_frame = ttk.LabelFrame(main_frame, text="RISK FACTOR WEIGHTS (must sum to 1.0)", padding="15")
        config_frame.pack(fill='x', pady=(0, 10))
        
        self.weight_vars = {}
        self.weight_sliders = {}
        self.weight_display_labels = {}
        
        # Mandatory factors (Entity, Region, Product)
        ttk.Label(config_frame, text="MANDATORY FACTORS:", font=('Arial', 10, 'bold')).grid(row=0, column=0, columnspan=3, sticky=tk.W, pady=(10, 5))
        
        mandatory_factors = [
            ('Entity Risk', 'entity', 0.15),
            ('Region Risk', 'region', 0.10),
            ('Product Risk', 'product', 0.25)
        ]
        
        row = 1
        for display_name, key, default_weight in mandatory_factors:
            frame = ttk.Frame(config_frame)
            frame.grid(row=row, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=5)
            
            ttk.Label(frame, text=display_name, width=20).pack(side='left')
            
            weight_var = tk.DoubleVar(value=default_weight)
            self.weight_vars[key] = weight_var
            
            slider = ttk.Scale(frame, from_=0, to=1, variable=weight_var, 
                              orient='horizontal', length=300,
                              command=lambda v, k=key: self.on_weight_change(k, v))
            slider.pack(side='left', padx=10, fill='x', expand=True)
            self.weight_sliders[key] = slider
            
            display_label = ttk.Label(frame, text="0.15", width=10, foreground='blue', font=('Arial', 10, 'bold'))
            display_label.pack(side='left', padx=10)
            self.weight_display_labels[key] = display_label
            
            self.weight_vars[key].trace('w', lambda *args, k=key: self.update_weight_display(k))
            row += 1
        
        # Optional factors (Value, Aging, Reason)
        ttk.Label(config_frame, text="OPTIONAL RISK FACTORS (if selected):", font=('Arial', 10, 'bold')).grid(row=row, column=0, columnspan=3, sticky=tk.W, pady=(10, 5))
        row += 1
        
        optional_factors = [
            ('Value Risk', 'value', 0.25),
            ('Aging Risk', 'aging', 0.15),
            ('Reason Code Risk', 'reason', 0.10)
        ]
        
        for display_name, key, default_weight in optional_factors:
            frame = ttk.Frame(config_frame)
            frame.grid(row=row, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=5)
            
            ttk.Label(frame, text=display_name, width=20).pack(side='left')
            
            weight_var = tk.DoubleVar(value=default_weight)
            self.weight_vars[key] = weight_var
            
            slider = ttk.Scale(frame, from_=0, to=1, variable=weight_var, 
                              orient='horizontal', length=300,
                              command=lambda v, k=key: self.on_weight_change(k, v))
            slider.pack(side='left', padx=10, fill='x', expand=True)
            self.weight_sliders[key] = slider
            
            display_label = ttk.Label(frame, text="0.25", width=10, foreground='blue', font=('Arial', 10, 'bold'))
            display_label.pack(side='left', padx=10)
            self.weight_display_labels[key] = display_label
            
            self.weight_vars[key].trace('w', lambda *args, k=key: self.update_weight_display(k))
            row += 1
        
        # Normalize button
        ttk.Button(config_frame, text="Normalize Weights to 1.0", 
                  command=self.normalize_weights).grid(row=row, column=0, pady=10, sticky=tk.W)
        
        self.weight_sum_label = ttk.Label(config_frame, text="Total: 1.00", 
                                         font=('Arial', 10, 'bold'), foreground='green')
        self.weight_sum_label.grid(row=row, column=1, padx=20)
        
        # Calculate risk
        calc_frame = ttk.LabelFrame(main_frame, text="Risk Calculation", padding="10")
        calc_frame.pack(fill='x', pady=(0, 10))
        
        ttk.Button(calc_frame, text="Calculate Multi-Factor Risk Scores", 
                  command=self.calculate_composite_risk_scores).pack(side='left', padx=5)
        
        self.risk_calc_label = ttk.Label(calc_frame, text="Not calculated", foreground='gray')
        self.risk_calc_label.pack(side='left', padx=20)
        
        # Insights
        insights_frame = ttk.LabelFrame(main_frame, text="Population & Risk Insights", padding="10")
        insights_frame.pack(fill='both', expand=True)
        
        self.insights_text = tk.Text(insights_frame, height=25, width=100, font=('Courier', 9))
        scrollbar = ttk.Scrollbar(insights_frame, orient="vertical", command=self.insights_text.yview)
        self.insights_text.configure(yscrollcommand=scrollbar.set)
        
        self.insights_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    def create_tab3_widgets(self):
        """Sampling Tab"""
        params_frame = ttk.LabelFrame(self.tab3, text="Sampling Parameters", padding="10")
        params_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Label(params_frame, text="Confidence:").grid(row=0, column=0, sticky=tk.W)
        self.confidence_var = tk.StringVar(value="95")
        ttk.Combobox(params_frame, textvariable=self.confidence_var,
                    values=["90", "95", "99"], width=10).grid(row=0, column=1, padx=5)
        
        ttk.Label(params_frame, text="Margin of Error:").grid(row=0, column=2, sticky=tk.W, padx=(20,0))
        self.margin_var = tk.StringVar(value="0.05")
        ttk.Entry(params_frame, textvariable=self.margin_var, width=10).grid(row=0, column=3, padx=5)
        
        ttk.Label(params_frame, text="Expected Error Rate (p):").grid(row=1, column=0, sticky=tk.W)
        self.error_rate_var = tk.StringVar(value="0.15")
        ttk.Entry(params_frame, textvariable=self.error_rate_var, width=10).grid(row=1, column=1, padx=5)
        
        ttk.Label(params_frame, text="Anomaly Contamination (0-0.5):").grid(row=1, column=2, sticky=tk.W, padx=(20,0))
        self.contamination_var = tk.StringVar(value="0.05")
        ttk.Entry(params_frame, textvariable=self.contamination_var, width=10).grid(row=1, column=3, padx=5)
        
        # Methods
        methods_frame = ttk.LabelFrame(self.tab3, text="Sampling Methods", padding="10")
        methods_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        self.method_vars = {}
        for i, (name, key) in enumerate([
            ('Traditional Random (Baseline)', 'traditional'),
            ('Risk-Stratified PPS (Recommended)', 'risk_pps'),
            ('Hybrid (PPS + Anomalies)', 'hybrid')
        ]):
            var = tk.BooleanVar(value=(key != 'hybrid'))
            self.method_vars[key] = var
            ttk.Checkbutton(methods_frame, text=name, variable=var).grid(row=i, column=0, sticky=tk.W, padx=20, pady=5)
        
        ttk.Button(methods_frame, text="Generate & Compare Samples", 
                  command=self.generate_comparison_samples).grid(row=3, column=0, pady=20, sticky=(tk.W, tk.E), padx=20)
        
        # Results
        results_frame = ttk.LabelFrame(self.tab3, text="Results & Comparison", padding="10")
        results_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        results_notebook = ttk.Notebook(results_frame)
        results_notebook.pack(fill='both', expand=True)
        
        # Summary table
        summary_frame = ttk.Frame(results_notebook)
        results_notebook.add(summary_frame, text="Summary")
        
        self.summary_tree = ttk.Treeview(summary_frame, 
                                        columns=("Size", "High_Risk", "Coverage", "Avg_Risk", "Strata"), 
                                        show="tree headings", height=15)
        self.summary_tree.heading("#0", text="Method")
        for col in ["Size", "High_Risk", "Coverage", "Avg_Risk", "Strata"]:
            self.summary_tree.heading(col, text=col)
            self.summary_tree.column(col, width=100)
        
        scrollbar = ttk.Scrollbar(summary_frame, orient="vertical", command=self.summary_tree.yview)
        self.summary_tree.configure(yscrollcommand=scrollbar.set)
        self.summary_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Insights
        insights_frame = ttk.Frame(results_notebook)
        results_notebook.add(insights_frame, text="Insights")
        
        self.sampling_insights_text = tk.Text(insights_frame, height=20, width=100, font=('Courier', 9))
        insights_scrollbar = ttk.Scrollbar(insights_frame, orient="vertical", command=self.sampling_insights_text.yview)
        self.sampling_insights_text.configure(yscrollcommand=insights_scrollbar.set)
        self.sampling_insights_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        insights_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Export
        export_frame = ttk.Frame(results_frame)
        export_frame.pack(fill='x', pady=5)
        
        ttk.Button(export_frame, text="Export Samples", command=self.export_samples).pack(side='left', padx=5)
        ttk.Button(export_frame, text="Export Out-of-Scope", command=self.export_out_of_scope).pack(side='left', padx=5)
        ttk.Button(export_frame, text="Export Report", command=self.export_report).pack(side='left', padx=5)
        ttk.Button(export_frame, text="Export All", command=self.export_all_results).pack(side='left', padx=5)
        
        self.tab3.rowconfigure(2, weight=1)
        self.tab3.columnconfigure(0, weight=1)
    
    def create_tab4_widgets(self):
        """Coverage Analysis Tab"""
        self.coverage_notebook = ttk.Notebook(self.tab4)
        self.coverage_notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        self.method_coverage_tabs = {}
        
        methods = [
            ('Traditional Random', 'traditional'),
            ('Risk-Stratified PPS', 'risk_pps'),
            ('Hybrid', 'hybrid')
        ]
        
        for display_name, method_key in methods:
            method_frame = ttk.Frame(self.coverage_notebook)
            self.coverage_notebook.add(method_frame, text=display_name)
            
            sub_notebook = ttk.Notebook(method_frame)
            sub_notebook.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Missed strata
            missed_frame = ttk.Frame(sub_notebook)
            sub_notebook.add(missed_frame, text="Missed Strata")
            
            missed_tree = ttk.Treeview(missed_frame, 
                                       columns=("Population", "Avg_Risk", "Reason"), 
                                       show="tree headings", height=20)
            missed_tree.heading("#0", text="Stratum")
            missed_tree.heading("Population", text="Population")
            missed_tree.heading("Avg_Risk", text="Avg Risk")
            missed_tree.heading("Reason", text="Reason")
            
            missed_tree.column("#0", width=400)
            for col in ["Population", "Avg_Risk", "Reason"]:
                missed_tree.column(col, width=120)
            
            missed_scrollbar_y = ttk.Scrollbar(missed_frame, orient="vertical", command=missed_tree.yview)
            missed_scrollbar_x = ttk.Scrollbar(missed_frame, orient="horizontal", command=missed_tree.xview)
            missed_tree.configure(yscrollcommand=missed_scrollbar_y.set, xscrollcommand=missed_scrollbar_x.set)
            
            missed_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
            missed_scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
            missed_scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
            
            missed_frame.rowconfigure(0, weight=1)
            missed_frame.columnconfigure(0, weight=1)
            
            # All strata
            all_frame = ttk.Frame(sub_notebook)
            sub_notebook.add(all_frame, text="All Strata")
            
            all_tree = ttk.Treeview(all_frame, 
                                    columns=("Population", "Sampled", "Coverage", "Avg_Risk", "Allocation_Reason"), 
                                    show="tree headings", height=20)
            all_tree.heading("#0", text="Stratum")
            all_tree.heading("Population", text="Population")
            all_tree.heading("Sampled", text="Sampled")
            all_tree.heading("Coverage", text="Coverage %")
            all_tree.heading("Avg_Risk", text="Avg Risk")
            all_tree.heading("Allocation_Reason", text="Allocation Reason")
            
            all_tree.column("#0", width=350)
            for col in ["Population", "Sampled", "Coverage", "Avg_Risk"]:
                all_tree.column(col, width=80)
            all_tree.column("Allocation_Reason", width=150)
            
            all_scrollbar_y = ttk.Scrollbar(all_frame, orient="vertical", command=all_tree.yview)
            all_scrollbar_x = ttk.Scrollbar(all_frame, orient="horizontal", command=all_tree.xview)
            all_tree.configure(yscrollcommand=all_scrollbar_y.set, xscrollcommand=all_scrollbar_x.set)
            
            all_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
            all_scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
            all_scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
            
            all_frame.rowconfigure(0, weight=1)
            all_frame.columnconfigure(0, weight=1)
            
            self.method_coverage_tabs[method_key] = {
                'missed_tree': missed_tree,
                'all_tree': all_tree
            }
    
    def create_tab5_widgets(self):
        """Stratum-Based Analysis Report Tab"""
        control_frame = ttk.LabelFrame(self.tab5, text="Stratum Report Controls", padding="10")
        control_frame.pack(fill='x', pady=5)
        
        ttk.Button(control_frame, text="Generate Stratum Analysis Report", 
                  command=self.generate_stratum_report).pack(side='left', padx=5)
        ttk.Button(control_frame, text="Export Stratum Report", 
                  command=self.export_stratum_report).pack(side='left', padx=5)
        
        report_frame = ttk.LabelFrame(self.tab5, text="Stratum Allocation Analysis", padding="10")
        report_frame.pack(fill='both', expand=True, pady=5)
        
        self.stratum_report_tree = ttk.Treeview(report_frame, 
                                               columns=("Pop", "MeanRisk", "RiskWeight", "Allocated", "Coverage", "Reason"), 
                                               show="tree headings", height=30)
        
        self.stratum_report_tree.heading("#0", text="Stratum (Entity|Region|Product|...)")
        for col in ["Pop", "MeanRisk", "RiskWeight", "Allocated", "Coverage", "Reason"]:
            self.stratum_report_tree.heading(col, text=col)
        
        self.stratum_report_tree.column("#0", width=450)
        for col in ["Pop", "MeanRisk", "RiskWeight", "Allocated", "Coverage", "Reason"]:
            self.stratum_report_tree.column(col, width=100)
        
        scrollbar_y = ttk.Scrollbar(report_frame, orient="vertical", command=self.stratum_report_tree.yview)
        scrollbar_x = ttk.Scrollbar(report_frame, orient="horizontal", command=self.stratum_report_tree.xview)
        self.stratum_report_tree.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        self.stratum_report_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
        scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        report_frame.rowconfigure(0, weight=1)
        report_frame.columnconfigure(0, weight=1)
    
    def create_tab6_widgets(self):
        """Visualizations Tab"""
        control_frame = ttk.LabelFrame(self.tab6, text="Controls", padding="10")
        control_frame.pack(fill='x', pady=5)
        
        ttk.Button(control_frame, text="Generate Charts", 
                  command=self.update_visualizations).pack(side='left', padx=5)
        
        viz_frame = ttk.LabelFrame(self.tab6, text="Charts & Graphs", padding="10")
        viz_frame.pack(fill='both', expand=True, pady=5)
        
        self.fig, self.axes = plt.subplots(2, 3, figsize=(18, 10))
        self.fig.tight_layout(pad=3.0)
        
        self.canvas = FigureCanvasTkAgg(self.fig, master=viz_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        self.tab6.rowconfigure(0, weight=1)
        self.tab6.columnconfigure(0, weight=1)
        viz_frame.rowconfigure(0, weight=1)
        viz_frame.columnconfigure(0, weight=1)
    
    # ===== DATA LOADING =====
    
    def load_data(self):
        file_path = filedialog.askopenfilename(
            title="Select Data File",
            filetypes=[("CSV", "*.csv"), ("Excel", "*.xlsx"), ("All", "*.*")]
        )
        
        if file_path:
            try:
                if file_path.endswith('.csv'):
                    df = pd.read_csv(file_path)
                else:
                    df = pd.read_excel(file_path)
                
                self.data = df
                self.update_column_dropdowns()
                self.update_data_preview()
                self.data_label.config(text=f"✓ Loaded {len(df):,} records", foreground='green')
                messagebox.showinfo("Success", f"Loaded {len(df):,} records")
            except Exception as e:
                messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def generate_sample_data(self):
        try:
            np.random.seed(42)
            n = 183823
            
            entity_regions = {
                'HBAP': ['LN', 'AU', 'IN', 'PA', 'HK', 'SG'],
                'HBEU': ['LN', 'PA', 'FR', 'DE', 'IT', 'CH'],
                'HBUS': ['NY', 'CA', 'TX', 'IL', 'FL']
            }
            
            products = ['Cash_Bonds', 'Equities', 'IRD', 'FX_Derivatives', 
                       'ABS_MBS', 'Structured_Products', 'Repo', 'Commodities']
            
            reason_codes = ['Price_Mismatch', 'Model_Error', 'Data_Quality', 'Process_Delay',
                           'System_Error', 'Manual_Override', 'Counterparty_Issue', 'Settlement_Delay']
            
            entities = []
            regions = []
            entity_probs = {'HBAP': 0.45, 'HBEU': 0.35, 'HBUS': 0.20}
            
            for _ in range(n):
                entity = np.random.choice(list(entity_regions.keys()), p=list(entity_probs.values()))
                region = np.random.choice(entity_regions[entity])
                entities.append(entity)
                regions.append(region)
            
            data = {
                'exception_id': range(1, n + 1),
                'legal_entity': entities,
                'region': regions,
                'product_type': np.random.choice(products, n, 
                                               p=[0.25, 0.20, 0.15, 0.12, 0.08, 0.06, 0.08, 0.06]),
                'reason_code': np.random.choice(reason_codes, n,
                                              p=[0.25, 0.15, 0.15, 0.10, 0.10, 0.08, 0.10, 0.07]),
                'trade_value': np.random.lognormal(15, 1.5, n),
                'aging_days': np.random.exponential(8, n).astype(int),
                'desk_id': [f"DESK_{i:02d}" for i in np.random.randint(1, 31, n)]
            }
            
            df = pd.DataFrame(data)
            self.data = df
            self.update_column_dropdowns()
            self.update_data_preview()
            self.data_label.config(text=f"✓ Generated {len(df):,} records", foreground='green')
            messagebox.showinfo("Success", f"Generated {len(df):,} records")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def update_column_dropdowns(self):
        """Update mandatory column dropdowns with all data columns"""
        if self.data is None: return
        
        columns = list(self.data.columns)
        
        self.entity_col_combo['values'] = columns
        self.region_col_combo['values'] = columns
        self.product_col_combo['values'] = columns
        
        # Auto-detect if possible
        for col in self.data.columns:
            col_lower = col.lower()
            if 'entity' in col_lower or 'legal' in col_lower:
                self.entity_col_var.set(col)
            elif 'region' in col_lower or 'hub' in col_lower:
                self.region_col_var.set(col)
            elif 'product' in col_lower or 'type' in col_lower:
                self.product_col_var.set(col)
    
    def update_data_preview(self):
        """Update data preview tree with first 50 rows"""
        if self.data is None: return
        
        for item in self.tree.get_children():
            self.tree.delete(item)
        
        display_cols = list(self.data.columns)[:10]
        
        self.tree["columns"] = display_cols
        self.tree["show"] = "headings"
        
        for col in display_cols:
            self.tree.heading(col, text=col.replace('_', ' ').title())
            self.tree.column(col, width=120)
        
        for _, row in self.data.head(50).iterrows():
            values = [str(row.get(col, '')) for col in display_cols]
            self.tree.insert("", "end", values=values)
    
    def open_risk_factor_selector(self):
        """Allow user to select which columns to use as risk factors"""
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        mandatory_cols = [self.entity_col_var.get(), self.region_col_var.get(), self.product_col_var.get()]
        available_cols = [col for col in self.data.columns if col not in mandatory_cols]
        
        dialog = Toplevel(self.root)
        dialog.title("Select Risk Factor Columns")
        dialog.geometry("600x500")
        
        ttk.Label(dialog, text="Select columns for Value, Aging, and Reason Code risk factors:", 
                 font=('Arial', 10, 'bold')).pack(pady=10)
        ttk.Label(dialog, text="(Leave unchecked to skip)", font=('Arial', 9), foreground='gray').pack()
        
        # Create frames for each risk factor
        factor_selections = {}
        
        for factor_name, factor_key in [('Value Risk (numeric)', 'value'), 
                                        ('Aging Risk (numeric)', 'aging'), 
                                        ('Reason Code Risk (categorical)', 'reason')]:
            frame = ttk.LabelFrame(dialog, text=factor_name, padding="10")
            frame.pack(fill='x', padx=10, pady=5)
            
            selected_var = tk.StringVar(value=self.risk_config[factor_key]['column'] or '')
            factor_selections[factor_key] = selected_var
            
            combo = ttk.Combobox(frame, textvariable=selected_var, values=available_cols, width=50)
            combo.pack(fill='x', padx=5, pady=5)
            
            ttk.Label(frame, text=f"Click to select a column for {factor_name.lower()}", 
                     font=('Arial', 8), foreground='gray').pack()
        
        def confirm():
            for factor_key, var in factor_selections.items():
                col = var.get().strip()
                if col and col in self.data.columns:
                    self.risk_config[factor_key]['enabled'] = True
                    self.risk_config[factor_key]['column'] = col
                else:
                    self.risk_config[factor_key]['enabled'] = False
                    self.risk_config[factor_key]['column'] = None
            
            # Update label
            selected = [f"{k.upper()}: {v['column']}" for k, v in self.risk_config.items() if v['enabled']]
            if selected:
                self.risk_factor_label.config(
                    text=f"✓ Selected: {', '.join(selected)}",
                    foreground='blue'
                )
            else:
                self.risk_factor_label.config(text="None selected", foreground='gray')
            
            dialog.destroy()
        
        ttk.Button(dialog, text="Confirm", command=confirm).pack(pady=20)
    
    def open_column_selector(self):
        """Select additional stratification columns"""
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        mandatory_cols = [self.entity_col_var.get(), self.region_col_var.get(), self.product_col_var.get()]
        available_cols = [col for col in self.data.columns if col not in mandatory_cols]
        
        dialog = Toplevel(self.root)
        dialog.title("Select Stratification Columns")
        dialog.geometry("500x400")
        
        ttk.Label(dialog, text="Select additional columns for stratification:", font=('Arial', 10, 'bold')).pack(pady=10)
        ttk.Label(dialog, text="(Ctrl/Cmd for multiple)", font=('Arial', 9), foreground='gray').pack()
        
        frame = ttk.Frame(dialog)
        frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        scrollbar = ttk.Scrollbar(frame)
        scrollbar.pack(side='right', fill='y')
        
        listbox = Listbox(frame, selectmode=MULTIPLE, yscrollcommand=scrollbar.set, font=('Arial', 10))
        listbox.pack(side='left', fill='both', expand=True)
        scrollbar.config(command=listbox.yview)
        
        for col in available_cols:
            listbox.insert('end', col)
        
        for i, col in enumerate(available_cols):
            if col in self.selected_additional_columns:
                listbox.selection_set(i)
        
        def confirm():
            selected = listbox.curselection()
            self.selected_additional_columns = [available_cols[i] for i in selected]
            
            if self.selected_additional_columns:
                self.additional_cols_label.config(
                    text=f"Selected {len(self.selected_additional_columns)}: {', '.join(self.selected_additional_columns[:3])}{'...' if len(self.selected_additional_columns) > 3 else ''}",
                    foreground='blue'
                )
            else:
                self.additional_cols_label.config(text="None selected", foreground='gray')
            dialog.destroy()
        
        ttk.Button(dialog, text="Confirm", command=confirm).pack(pady=10)
    
    # ===== RISK SCORE CALCULATION =====
    
    def on_weight_change(self, key, value):
        """Called when weight slider changes"""
        self.update_weight_display(key)
    
    def update_weight_display(self, key):
        """Update weight display and sum"""
        total = sum(self.weight_vars[k].get() for k in self.weight_vars)
        
        # Update label color based on total
        color = 'green' if abs(total - 1.0) < 0.01 else 'red'
        self.weight_sum_label.config(text=f"Total: {total:.2f}", foreground=color)
        
        # Update individual weight display
        if key in self.weight_display_labels:
            self.weight_display_labels[key].config(text=f"{self.weight_vars[key].get():.2f}")
    
    def normalize_weights(self):
        """Normalize all weights to sum to 1.0"""
        total = sum(self.weight_vars[k].get() for k in self.weight_vars)
        if total > 0:
            for k in self.weight_vars:
                normalized = self.weight_vars[k].get() / total
                self.weight_vars[k].set(normalized)
            self.update_weight_display(list(self.weight_vars.keys())[0])
            messagebox.showinfo("Success", "Weights normalized to sum = 1.0")
    
    def calculate_composite_risk_scores(self):
        """Calculate multi-factor composite risk score"""
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        try:
            # Get mandatory column names
            entity_col = self.entity_col_var.get()
            region_col = self.region_col_var.get()
            product_col = self.product_col_var.get()
            
            required = [entity_col, region_col, product_col]
            missing = [col for col in required if col not in self.data.columns]
            
            if missing:
                messagebox.showerror("Error", f"Missing mandatory columns: {missing}")
                return
            
            # Start with a copy
            df = self.data.copy()
            
            # ===== MANDATORY FACTORS =====
            entity_risk = self._calculate_factor_risk(df, entity_col, 'Entity')
            region_risk = self._calculate_factor_risk(df, region_col, 'Region')
            
            # Product risk (expert-assigned)
            product_risk = df[product_col].map(
                lambda x: self.expert_product_risk.get(str(x), 0.5)
            ).fillna(0.5)
            
            # ===== OPTIONAL FACTORS =====
            risk_components = []
            active_weights = {}
            
            # Add mandatory factors
            risk_components.append(self.weight_vars['entity'].get() * entity_risk)
            active_weights['entity'] = self.weight_vars['entity'].get()
            
            risk_components.append(self.weight_vars['region'].get() * region_risk)
            active_weights['region'] = self.weight_vars['region'].get()
            
            risk_components.append(self.weight_vars['product'].get() * product_risk)
            active_weights['product'] = self.weight_vars['product'].get()
            
            # VALUE RISK
            if self.risk_config['value']['enabled'] and self.risk_config['value']['column']:
                value_col = self.risk_config['value']['column']
                if value_col in df.columns:
                    df = self.ensure_numeric_column(df, value_col)
                    value_risk = self._normalize_to_risk_score(df[value_col].fillna(0), name='Trade Value')
                    risk_components.append(self.weight_vars['value'].get() * value_risk)
                    active_weights['value'] = self.weight_vars['value'].get()
            
            # AGING RISK
            if self.risk_config['aging']['enabled'] and self.risk_config['aging']['column']:
                aging_col = self.risk_config['aging']['column']
                if aging_col in df.columns:
                    df = self.ensure_numeric_column(df, aging_col)
                    aging_risk = self._normalize_to_risk_score(df[aging_col].fillna(0), name='Aging')
                    risk_components.append(self.weight_vars['aging'].get() * aging_risk)
                    active_weights['aging'] = self.weight_vars['aging'].get()
            
            # REASON CODE RISK
            if self.risk_config['reason']['enabled'] and self.risk_config['reason']['column']:
                reason_col = self.risk_config['reason']['column']
                if reason_col in df.columns:
                    reason_risk = df[reason_col].map(
                        lambda x: self.expert_reason_risk.get(str(x), 0.5)
                    ).fillna(0.5)
                    risk_components.append(self.weight_vars['reason'].get() * reason_risk)
                    active_weights['reason'] = self.weight_vars['reason'].get()
            
            # ===== NORMALIZE WEIGHTS AND CALCULATE COMPOSITE =====
            total_weight = sum(active_weights.values())
            if total_weight == 0:
                raise ValueError("No active risk factors selected. Please enable at least one optional factor or verify mandatory factors.")
            
            # Normalize weights
            normalized_weights = {k: v / total_weight for k, v in active_weights.items()}
            
            # Recalculate components with normalized weights
            risk_components = []
            
            risk_components.append(normalized_weights.get('entity', 0) * entity_risk)
            risk_components.append(normalized_weights.get('region', 0) * region_risk)
            risk_components.append(normalized_weights.get('product', 0) * product_risk)
            
            if self.risk_config['value']['enabled'] and self.risk_config['value']['column']:
                value_col = self.risk_config['value']['column']
                if value_col in df.columns:
                    df = self.ensure_numeric_column(df, value_col)
                    value_risk = self._normalize_to_risk_score(df[value_col].fillna(0))
                    risk_components.append(normalized_weights.get('value', 0) * value_risk)
            
            if self.risk_config['aging']['enabled'] and self.risk_config['aging']['column']:
                aging_col = self.risk_config['aging']['column']
                if aging_col in df.columns:
                    df = self.ensure_numeric_column(df, aging_col)
                    aging_risk = self._normalize_to_risk_score(df[aging_col].fillna(0))
                    risk_components.append(normalized_weights.get('aging', 0) * aging_risk)
            
            if self.risk_config['reason']['enabled'] and self.risk_config['reason']['column']:
                reason_col = self.risk_config['reason']['column']
                if reason_col in df.columns:
                    reason_risk = df[reason_col].map(
                        lambda x: self.expert_reason_risk.get(str(x), 0.5)
                    ).fillna(0.5)
                    risk_components.append(normalized_weights.get('reason', 0) * reason_risk)
            
            # Calculate composite risk score
            composite = sum(risk_components)
            df['risk_score'] = np.clip(composite, 0.01, 1.0)
            df = self.ensure_numeric_column(df, 'risk_score')
            
            # Store data
            self.data = df
            
            # ===== DEFINE STRATA =====
            stratum_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
            stratum_cols = [col for col in stratum_cols if col in self.data.columns]
            self.stratum_columns = stratum_cols
            
            self.data['stratum'] = self.data[stratum_cols].apply(
                lambda x: '|'.join(x.astype(str)), axis=1
            )
            
            self.total_strata_count = len(self.data.groupby(stratum_cols))
            
            # Update displays
            self.update_population_insights(active_weights)
            
            self.risk_calc_label.config(
                text=f"✓ Calculated ({len(stratum_cols)} dimensions, {self.total_strata_count:,} strata, {len(active_weights)} factors)",
                foreground='green'
            )
            
            messagebox.showinfo("Success", 
                f"Risk scores calculated\nDimensions: {len(stratum_cols)} | Strata: {self.total_strata_count:,} | Factors: {len(active_weights)}")
        
        except Exception as e:
            messagebox.showerror("Error", f"Calculation failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def _calculate_factor_risk(self, df, column, factor_name):
        """Calculate risk for a categorical factor using frequency"""
        counts = df[column].value_counts()
        total = len(df)
        frequencies = counts / total
        
        min_f = frequencies.min()
        max_f = frequencies.max()
        
        if max_f > min_f:
            weights = 0.1 + 0.9 * (frequencies - min_f) / (max_f - min_f)
        else:
            weights = pd.Series(0.5, index=frequencies.index)
        
        return df[column].map(weights).fillna(0.5)
    
    def _normalize_to_risk_score(self, series, name='Feature'):
        """Normalize numeric series to [0.1, 1.0] risk score"""
        series = series.fillna(0)
        min_val = series.min()
        max_val = series.max()
        
        if max_val > min_val:
            normalized = 0.1 + 0.9 * (series - min_val) / (max_val - min_val)
        else:
            normalized = pd.Series(0.5, index=series.index)
        
        return normalized
    
    def update_population_insights(self, active_weights):
        """Update population insights"""
        self.insights_text.delete(1.0, tk.END)
        
        if self.data is None or 'risk_score' not in self.data.columns:
            self.insights_text.insert(1.0, "Calculate risk scores first")
            return
        
        stratum_groups = self.data.groupby(self.stratum_columns) if self.stratum_columns else None
        
        total_strata = len(stratum_groups) if stratum_groups else 1
        
        high_risk = len(self.data[self.data['risk_score'] > 0.7])
        medium_risk = len(self.data[(self.data['risk_score'] >= 0.3) & (self.data['risk_score'] <= 0.7)])
        low_risk = len(self.data[self.data['risk_score'] < 0.3])
        
        insights = f"""
╔══════════════════════════════════════════════════════════════════════════════╗
║                    POPULATION & RISK PROFILE ANALYSIS                        ║
╚══════════════════════════════════════════════════════════════════════════════╝

Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

POPULATION SUMMARY
═══════════════════════════════════════════════════════════════════════════════
Total Records:                 {len(self.data):,}
Unique Strata:                 {total_strata:,}
Stratification Dimensions:     {len(self.stratum_columns)}
  • Mandatory (3):             Entity, Region, Product
  • Additional ({len(self.selected_additional_columns)}):        {', '.join(self.selected_additional_columns) if self.selected_additional_columns else 'None'}

RISK DISTRIBUTION (Multi-Factor Score)
═══════════════════════════════════════════════════════════════════════════════
High-Risk (0.7-1.0):           {high_risk:,} records ({high_risk/len(self.data)*100:.1f}%)
Medium-Risk (0.3-0.7):         {medium_risk:,} records ({medium_risk/len(self.data)*100:.1f}%)
Low-Risk (0.01-0.3):           {low_risk:,} records ({low_risk/len(self.data)*100:.1f}%)

STRATUM STATISTICS
═══════════════════════════════════════════════════════════════════════════════
"""
        
        if stratum_groups:
            stratum_sizes = stratum_groups.size()
            insights += f"""Largest Stratum:               {stratum_sizes.max():,} records
Smallest Stratum:              {stratum_sizes.min():,} records
Average Stratum Size:          {stratum_sizes.mean():.1f} records
Median Stratum Size:           {stratum_sizes.median():.1f} records
Strata with <5 records:        {len(stratum_sizes[stratum_sizes < 5]):,} ({len(stratum_sizes[stratum_sizes < 5])/len(stratum_sizes)*100:.1f}%)

"""
        
        # Top 10 highest-risk strata
        if stratum_groups:
            stratum_risk = self.data.groupby(self.stratum_columns)['risk_score'].agg(['mean', 'count']).reset_index()
            stratum_risk.columns = list(self.stratum_columns) + ['mean_risk', 'population']
            stratum_risk = stratum_risk.sort_values('mean_risk', ascending=False)
            
            insights += f"""TOP 10 HIGHEST-RISK STRATA
═══════════════════════════════════════════════════════════════════════════════
"""
            for idx, (i, row) in enumerate(stratum_risk.head(10).iterrows(), 1):
                stratum_name = '|'.join(str(row[col]) for col in self.stratum_columns)
                insights += f"{idx:2d}. {stratum_name}\n"
                insights += f"    Mean Risk: {row['mean_risk']:.3f}  |  Population: {row['population']:,}\n\n"
        
        insights += f"""
RISK SCORE COMPONENTS (Configured Weights)
═══════════════════════════════════════════════════════════════════════════════
"""
        
        for factor, weight in active_weights.items():
            insights += f"{factor.upper():20s}: {weight:.2%}\n"
        
        insights += f"""                               ──────
                               Total: {sum(active_weights.values()):.2%}

KEY INSIGHTS
═══════════════════════════════════════════════════════════════════════════════
• Multi-factor risk score incorporates selected business factors
• Risk-Stratified PPS allocation prioritizes high-risk, high-value strata
• Small, low-risk strata intentionally under-sampled to maximize detection power
• Stratum-based analysis provides per-strata allocation justification for auditors
"""
        
        self.insights_text.insert(1.0, insights)
    
    # ===== SAMPLING METHODS =====
    
    def calculate_cochran_sample_size(self, confidence=95, margin=0.05, p=0.15):
        """Calculate sample size using Cochran's formula"""
        z_scores = {90: 1.645, 95: 1.96, 99: 2.576}
        z = z_scores.get(confidence, 1.96)
        q = 1 - p
        
        n = (z**2 * p * q) / (margin**2)
        
        N = len(self.data)
        if N > 0 and n > 0:
            n_finite = n / (1 + (n - 1) / N)
        else:
            n_finite = n
        
        return max(1, math.ceil(n_finite))
    
    def traditional_sampling(self, data, sample_size):
        """Simple random sampling"""
        sample_size = self.safe_int_conversion(sample_size, 100)
        
        if sample_size >= len(data):
            return data.copy(), {}
        
        sample = data.sample(n=sample_size, random_state=42)
        stratum_info = self._analyze_strata_sampling(data, sample, 'Traditional')
        
        return sample, stratum_info
    
    def risk_stratified_pps_sampling(self, data, target_size):
        """Stratified PPS sampling - RECOMMENDED METHOD"""
        target_size = self.safe_int_conversion(target_size, 100)
        data = self.ensure_numeric_column(data.copy(), 'risk_score')
        
        if 'stratum' not in data.columns:
            return self.traditional_sampling(data, target_size)
        
        stratum_groups = data.groupby(self.stratum_columns, observed=True)
        
        stratum_allocations = {}
        total_weighted = 0
        
        for name, group in stratum_groups:
            N_h = len(group)
            mean_risk_h = group['risk_score'].mean()
            size_weight = N_h * mean_risk_h
            
            stratum_allocations[name] = {
                'population': N_h,
                'mean_risk': mean_risk_h,
                'size_weight': size_weight,
                'group': group
            }
            total_weighted += size_weight
        
        stratum_samples = {}
        
        for name, details in stratum_allocations.items():
            if total_weighted > 0:
                n_h = max(0, int((details['size_weight'] / total_weighted) * target_size))
            else:
                n_h = 0
            
            n_h = min(n_h, details['population'])
            stratum_samples[name] = n_h
        
        total_allocated = sum(stratum_samples.values())
        
        if total_allocated < target_size:
            diff = target_size - total_allocated
            sorted_strata = sorted(stratum_allocations.items(),
                                 key=lambda x: x[1]['size_weight'],
                                 reverse=True)
            
            for name, _ in sorted_strata:
                if diff <= 0:
                    break
                
                can_add = min(diff, stratum_allocations[name]['population'] - stratum_samples[name])
                stratum_samples[name] += can_add
                total_allocated += can_add
                diff -= can_add
        
        elif total_allocated > target_size:
            diff = total_allocated - target_size
            sorted_strata = sorted(stratum_allocations.items(),
                                 key=lambda x: x[1]['size_weight'],
                                 reverse=False)
            
            for name, _ in sorted_strata:
                if diff <= 0:
                    break
                
                can_remove = min(diff, stratum_samples[name])
                stratum_samples[name] -= can_remove
                total_allocated -= can_remove
                diff -= can_remove
        
        samples = []
        
        for name, group in stratum_groups:
            sample_size_h = stratum_samples.get(name, 0)
            
            if sample_size_h > 0 and len(group) > 0:
                group = self.ensure_numeric_column(group.copy(), 'risk_score')
                
                if sample_size_h >= len(group):
                    samples.append(group)
                else:
                    high_risk_count = max(1, int(sample_size_h * 0.5))
                    
                    group_sorted = group.sort_values('risk_score', ascending=False)
                    high_risk_sample = group_sorted.head(min(high_risk_count, len(group_sorted)))
                    
                    remaining = sample_size_h - len(high_risk_sample)
                    
                    if remaining > 0:
                        remaining_data = group[~group.index.isin(high_risk_sample.index)]
                        if len(remaining_data) > 0:
                            random_sample = remaining_data.sample(
                                n=min(remaining, len(remaining_data)),
                                random_state=42
                            )
                            stratum_sample = pd.concat([high_risk_sample, random_sample])
                        else:
                            stratum_sample = high_risk_sample
                    else:
                        stratum_sample = high_risk_sample
                    
                    if len(stratum_sample) > 0:
                        samples.append(stratum_sample)
        
        if samples:
            final_sample = pd.concat(samples).drop_duplicates()
            if len(final_sample) < target_size:
                used = final_sample.index
                remaining_data = data[~data.index.isin(used)]
                if len(remaining_data) > 0:
                    needed = target_size - len(final_sample)
                    extra = remaining_data.sample(
                        n=min(needed, len(remaining_data)),
                        random_state=42
                    )
                    final_sample = pd.concat([final_sample, extra])
            
            sample = final_sample.head(target_size)
        else:
            sample = data.sample(n=min(target_size, len(data)), random_state=42)
        
        stratum_info = self._analyze_strata_sampling(data, sample, 'Risk-PPS')
        
        return sample, stratum_info
    
    def hybrid_pps_anomaly_sampling(self, data, target_size):
        """Hybrid: 70% Risk-PPS + 20% Anomalies + 10% Random"""
        target_size = self.safe_int_conversion(target_size, 100)
        data = self.ensure_numeric_column(data.copy(), 'risk_score')
        
        pps_size = int(target_size * 0.70)
        pps_sample, _ = self.risk_stratified_pps_sampling(data, pps_size)
        
        remaining = data[~data.index.isin(pps_sample.index)]
        
        anomaly_size = int(target_size * 0.20)
        
        if len(remaining) > anomaly_size and anomaly_size > 0:
            try:
                contamination = self.safe_float_conversion(self.contamination_var.get(), 0.05)
                contamination = min(0.5, max(0.01, contamination))
                
                X = remaining[['risk_score']].values
                if len(remaining) > 10:
                    iso_forest = IsolationForest(contamination=contamination, random_state=42)
                    anomaly_labels = iso_forest.fit_predict(X)
                    anomalies = remaining[anomaly_labels == -1]
                else:
                    anomalies = remaining.head(anomaly_size)
                
                if len(anomalies) > anomaly_size:
                    anomaly_sample = anomalies.sample(n=anomaly_size, random_state=42)
                else:
                    anomaly_sample = anomalies
            except:
                anomaly_sample = remaining.sample(n=min(anomaly_size, len(remaining)), random_state=42)
        else:
            anomaly_sample = remaining.head(min(anomaly_size, len(remaining)))
        
        random_remaining = data[~data.index.isin(pps_sample.index) & ~data.index.isin(anomaly_sample.index)]
        random_size = target_size - len(pps_sample) - len(anomaly_sample)
        
        if random_size > 0 and len(random_remaining) > 0:
            random_sample = random_remaining.sample(n=min(random_size, len(random_remaining)), random_state=42)
        else:
            random_sample = pd.DataFrame()
        
        hybrid_sample = pd.concat([pps_sample, anomaly_sample, random_sample]).drop_duplicates()
        
        if len(hybrid_sample) < target_size:
            unused = data[~data.index.isin(hybrid_sample.index)]
            if len(unused) > 0:
                needed = target_size - len(hybrid_sample)
                extra = unused.sample(n=min(needed, len(unused)), random_state=42)
                hybrid_sample = pd.concat([hybrid_sample, extra])
        
        sample = hybrid_sample.head(target_size)
        stratum_info = self._analyze_strata_sampling(data, sample, 'Hybrid')
        
        return sample, stratum_info
    
    def _analyze_strata_sampling(self, full_data, sample_data, method_name):
        """Analyze sampling results by stratum"""
        if 'stratum' not in full_data.columns:
            return {}
        
        stratum_groups = full_data.groupby(self.stratum_columns, observed=True)
        
        analysis = {}
        
        for name, group in stratum_groups:
            population = len(group)
            mean_risk = group['risk_score'].mean()
            sampled = len(sample_data[sample_data['stratum'] == group['stratum'].iloc[0]]) if 'stratum' in sample_data.columns else 0
            coverage = (sampled / population * 100) if population > 0 else 0
            
            analysis[str(name)] = {
                'population': population,
                'mean_risk': mean_risk,
                'sampled': sampled,
                'coverage': coverage
            }
        
        return analysis
    
    def generate_comparison_samples(self):
        """Generate and compare all selected methods"""
        if self.data is None or 'risk_score' not in self.data.columns:
            messagebox.showerror("Error", "Calculate risk scores first (Tab 2)")
            return
        
        try:
            confidence = self.safe_int_conversion(self.confidence_var.get(), 95)
            margin = self.safe_float_conversion(self.margin_var.get(), 0.05)
            error_rate = self.safe_float_conversion(self.error_rate_var.get(), 0.15)
            
            global_sample_size = self.calculate_cochran_sample_size(confidence, margin, error_rate)
            
            self.comparison_results = {}
            self.out_of_scope_data = {}
            self.missed_strata = {}
            
            if self.method_vars['traditional'].get():
                trad_sample, trad_info = self.traditional_sampling(self.data, global_sample_size)
                self.comparison_results['traditional'] = {
                    'sample': trad_sample,
                    'stratum_info': trad_info
                }
                self.out_of_scope_data['traditional'] = self.data[~self.data.index.isin(trad_sample.index)]
            
            if self.method_vars['risk_pps'].get():
                pps_sample, pps_info = self.risk_stratified_pps_sampling(self.data, global_sample_size)
                self.comparison_results['risk_pps'] = {
                    'sample': pps_sample,
                    'stratum_info': pps_info
                }
                self.out_of_scope_data['risk_pps'] = self.data[~self.data.index.isin(pps_sample.index)]
            
            if self.method_vars['hybrid'].get():
                hybrid_size = int(global_sample_size * 1.3)
                hybrid_sample, hybrid_info = self.hybrid_pps_anomaly_sampling(self.data, hybrid_size)
                self.comparison_results['hybrid'] = {
                    'sample': hybrid_sample,
                    'stratum_info': hybrid_info
                }
                self.out_of_scope_data['hybrid'] = self.data[~self.data.index.isin(hybrid_sample.index)]
            
            self.update_summary_table(global_sample_size)
            self.update_coverage_analysis()
            self.update_sampling_insights(global_sample_size)
            
            messagebox.showinfo("Success", "Samples generated successfully!")
        
        except Exception as e:
            messagebox.showerror("Error", f"Sampling failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def update_summary_table(self, cochran_size):
        """Update sampling summary table"""
        for item in self.summary_tree.get_children():
            self.summary_tree.delete(item)
        
        for method_key in ['traditional', 'risk_pps', 'hybrid']:
            if method_key not in self.comparison_results:
                continue
            
            sample = self.comparison_results[method_key]['sample']
            stratum_info = self.comparison_results[method_key]['stratum_info']
            
            covered_strata = sum(1 for info in stratum_info.values() if info['sampled'] > 0)
            
            high_risk_in_sample = len(sample[sample['risk_score'] > 0.7])
            high_risk_total = len(self.data[self.data['risk_score'] > 0.7])
            high_risk_pct = (high_risk_in_sample / high_risk_total * 100) if high_risk_total > 0 else 0
            
            display_name = {
                'traditional': 'Traditional Random',
                'risk_pps': 'Risk-Stratified PPS',
                'hybrid': 'Hybrid (PPS + Anomalies)'
            }.get(method_key, method_key)
            
            avg_risk = sample['risk_score'].mean() if len(sample) > 0 else 0
            
            self.summary_tree.insert("", "end", text=display_name,
                                    values=(
                                        len(sample),
                                        f"{high_risk_pct:.1f}%",
                                        f"{covered_strata}/{self.total_strata_count}",
                                        f"{avg_risk:.3f}",
                                        str(covered_strata)
                                    ))
    
    def update_coverage_analysis(self):
        """Update per-method coverage analysis"""
        for method_key in ['traditional', 'risk_pps', 'hybrid']:
            if method_key not in self.method_coverage_tabs or method_key not in self.comparison_results:
                continue
            
            sample = self.comparison_results[method_key]['sample']
            stratum_groups = self.data.groupby(self.stratum_columns, observed=True)
            
            missed_tree = self.method_coverage_tabs[method_key]['missed_tree']
            all_tree = self.method_coverage_tabs[method_key]['all_tree']
            
            for item in missed_tree.get_children():
                missed_tree.delete(item)
            for item in all_tree.get_children():
                all_tree.delete(item)
            
            for name, group in stratum_groups:
                population = len(group)
                mean_risk = group['risk_score'].mean()
                stratum_str = '|'.join(str(n) for n in name)
                
                sampled = len(sample[sample['stratum'] == stratum_str]) if 'stratum' in sample.columns else 0
                coverage = (sampled / population * 100) if population > 0 else 0
                
                reason = "High risk & large" if mean_risk > 0.7 and population > 100 else \
                        "Low risk & small" if mean_risk < 0.3 and population < 10 else \
                        "Medium risk"
                
                all_tree.insert("", "end", text=stratum_str,
                              values=(population, sampled, f"{coverage:.1f}%", f"{mean_risk:.3f}", reason))
                
                if sampled == 0:
                    reason = "Low risk score" if mean_risk < 0.3 else \
                            "Small population" if population < 5 else \
                            "Stratum priority"
                    
                    missed_tree.insert("", "end", text=stratum_str,
                                     values=(population, f"{mean_risk:.3f}", reason))
    
    def update_sampling_insights(self, cochran_size):
        """Update sampling insights"""
        self.sampling_insights_text.delete(1.0, tk.END)
        
        insights = f"""╔═══════════════════════════════════════════════════════════════════════════════╗
║                       SAMPLING METHODOLOGY & RESULTS                          ║
╚═══════════════════════════════════════════════════════════════════════════════╝

COCHRAN'S SAMPLE SIZE
═══════════════════════════════════════════════════════════════════════════════
Global Sample Size: {cochran_size} records (Confidence: {self.confidence_var.get()}%, Margin: {self.margin_var.get()}, p: {self.error_rate_var.get()})

METHODOLOGY COMPARISON
═══════════════════════════════════════════════════════════════════════════════
"""
        
        if 'traditional' in self.comparison_results:
            trad_sample = self.comparison_results['traditional']['sample']
            trad_info = self.comparison_results['traditional']['stratum_info']
            covered_trad = sum(1 for info in trad_info.values() if info['sampled'] > 0)
            
            high_risk_trad = len(trad_sample[trad_sample['risk_score'] > 0.7])
            high_risk_total = len(self.data[self.data['risk_score'] > 0.7])
            
            insights += f"""
TRADITIONAL RANDOM SAMPLING
• Sample Size: {len(trad_sample):,} | Strata Covered: {covered_trad}/{self.total_strata_count} | High-Risk: {high_risk_trad}/{high_risk_total} ({high_risk_trad/high_risk_total*100:.1f}%)

"""
        
        if 'risk_pps' in self.comparison_results:
            pps_sample = self.comparison_results['risk_pps']['sample']
            pps_info = self.comparison_results['risk_pps']['stratum_info']
            covered_pps = sum(1 for info in pps_info.values() if info['sampled'] > 0)
            
            high_risk_pps = len(pps_sample[pps_sample['risk_score'] > 0.7])
            
            insights += f"""RISK-STRATIFIED PPS (RECOMMENDED)
• Sample Size: {len(pps_sample):,} | Strata Covered: {covered_pps}/{self.total_strata_count} | High-Risk: {high_risk_pps}/{high_risk_total} ({high_risk_pps/high_risk_total*100:.1f}%)
• Better Coverage: +{covered_pps - covered_trad} strata | Better High-Risk Detection: +{high_risk_pps - high_risk_trad} records

"""
        
        if 'hybrid' in self.comparison_results:
            hybrid_sample = self.comparison_results['hybrid']['sample']
            hybrid_info = self.comparison_results['hybrid']['stratum_info']
            covered_hybrid = sum(1 for info in hybrid_info.values() if info['sampled'] > 0)
            
            high_risk_hybrid = len(hybrid_sample[hybrid_sample['risk_score'] > 0.7])
            
            insights += f"""HYBRID (PPS + ANOMALIES)
• Sample Size: {len(hybrid_sample):,} | Strata Covered: {covered_hybrid}/{self.total_strata_count} | High-Risk: {high_risk_hybrid}/{high_risk_total} ({high_risk_hybrid/high_risk_total*100:.1f}%)

"""
        
        insights += """SUMMARY
═══════════════════════════════════════════════════════════════════════════════
Recommendation: Use Risk-Stratified PPS for better strata coverage and high-risk
detection with the same sample size as traditional random sampling.
"""
        
        self.sampling_insights_text.insert(1.0, insights)
    
    # ===== STRATUM REPORT =====
    
    def generate_stratum_report(self):
        """Generate detailed stratum allocation report"""
        if 'risk_pps' not in self.comparison_results or 'stratum' not in self.data.columns:
            messagebox.showerror("Error", "Run Risk-PPS sampling first")
            return
        
        for item in self.stratum_report_tree.get_children():
            self.stratum_report_tree.delete(item)
        
        pps_sample = self.comparison_results['risk_pps']['sample']
        stratum_groups = self.data.groupby(self.stratum_columns, observed=True)
        
        report_data = []
        
        for name, group in stratum_groups:
            population = len(group)
            mean_risk = group['risk_score'].mean()
            stratum_str = '|'.join(str(n) for n in name)
            
            sampled = len(pps_sample[pps_sample['stratum'] == stratum_str]) if 'stratum' in pps_sample.columns else 0
            coverage = (sampled / population * 100) if population > 0 else 0
            
            size_weight = population * mean_risk
            
            if sampled > 0:
                if mean_risk > 0.75:
                    reason = "High risk & large → prioritized"
                elif population > 500:
                    reason = "Large stratum → many samples"
                elif mean_risk > 0.5:
                    reason = "Above-median risk → included"
                else:
                    reason = "Proportional allocation"
            else:
                if mean_risk < 0.25:
                    reason = "Very low risk → intentionally missed"
                elif population < 3:
                    reason = "Minimal population → skipped"
                elif population < 10 and mean_risk < 0.3:
                    reason = "Small + low risk → deferred"
                else:
                    reason = "Below allocation threshold"
            
            report_data.append({
                'stratum': stratum_str,
                'population': population,
                'mean_risk': mean_risk,
                'size_weight': size_weight,
                'sampled': sampled,
                'coverage': coverage,
                'reason': reason
            })
        
        report_data.sort(key=lambda x: x['size_weight'], reverse=True)
        
        for data in report_data:
            self.stratum_report_tree.insert("", "end", text=data['stratum'],
                                           values=(
                                               data['population'],
                                               f"{data['mean_risk']:.3f}",
                                               f"{data['size_weight']:.1f}",
                                               data['sampled'],
                                               f"{data['coverage']:.1f}%",
                                               data['reason']
                                           ))
        
        messagebox.showinfo("Success", f"Stratum report generated for {len(report_data):,} strata")
    
    def export_stratum_report(self):
        """Export stratum report to CSV"""
        if not self.stratum_report_tree.get_children():
            messagebox.showerror("Error", "Generate report first")
            return
        
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = os.path.join(self.results_dir, f"Stratum_Report_{timestamp}.csv")
            
            report_data = []
            
            for item in self.stratum_report_tree.get_children():
                values = self.stratum_report_tree.item(item, 'values')
                text = self.stratum_report_tree.item(item, 'text')
                
                report_data.append({
                    'Stratum': text,
                    'Population': values[0],
                    'Mean_Risk': values[1],
                    'Risk_Weight': values[2],
                    'Sampled': values[3],
                    'Coverage_%': values[4],
                    'Allocation_Reason': values[5]
                })
            
            df = pd.DataFrame(report_data)
            df.to_csv(filename, index=False)
            
            messagebox.showinfo("Success", f"Exported: {os.path.basename(filename)}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")
    
    # ===== EXPORTS =====
    
    def export_samples(self):
        """Export samples for each method"""
        if not self.comparison_results:
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            for method_key, data in self.comparison_results.items():
                sample = data['sample']
                method_name = {
                    'traditional': 'Traditional',
                    'risk_pps': 'RiskPPS',
                    'hybrid': 'Hybrid'
                }.get(method_key, method_key)
                
                filename = os.path.join(self.results_dir, f"Sample_{method_name}_{timestamp}.csv")
                sample.to_csv(filename, index=False)
            
            messagebox.showinfo("Success", f"Exported to {self.results_dir}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")
    
    def export_out_of_scope(self):
        """Export out-of-scope data"""
        if not self.out_of_scope_data:
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            for method_key, data in self.out_of_scope_data.items():
                method_name = {
                    'traditional': 'Traditional',
                    'risk_pps': 'RiskPPS',
                    'hybrid': 'Hybrid'
                }.get(method_key, method_key)
                
                filename = os.path.join(self.results_dir, f"OutOfScope_{method_name}_{timestamp}.csv")
                data.to_csv(filename, index=False)
            
            messagebox.showinfo("Success", f"Exported to {self.results_dir}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")
    
    def export_report(self):
        """Export sampling report"""
        if not self.comparison_results:
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = os.path.join(self.results_dir, f"Sampling_Report_{timestamp}.txt")
            
            report = self.sampling_insights_text.get(1.0, tk.END)
            
            with open(filename, 'w') as f:
                f.write(report)
            
            messagebox.showinfo("Success", f"Exported: {os.path.basename(filename)}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")
    
    def export_all_results(self):
        """Export all results"""
        if not self.comparison_results:
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            # Samples
            for method_key, data in self.comparison_results.items():
                sample = data['sample']
                method_name = {
                    'traditional': 'Traditional',
                    'risk_pps': 'RiskPPS',
                    'hybrid': 'Hybrid'
                }.get(method_key, method_key)
                
                filename = os.path.join(self.results_dir, f"Sample_{method_name}_{timestamp}.csv")
                sample.to_csv(filename, index=False)
            
            # Out-of-scope
            for method_key, data in self.out_of_scope_data.items():
                method_name = {
                    'traditional': 'Traditional',
                    'risk_pps': 'RiskPPS',
                    'hybrid': 'Hybrid'
                }.get(method_key, method_key)
                
                filename = os.path.join(self.results_dir, f"OutOfScope_{method_name}_{timestamp}.csv")
                data.to_csv(filename, index=False)
            
            # Stratum report
            stratum_filename = os.path.join(self.results_dir, f"Stratum_Report_{timestamp}.csv")
            
            report_data = []
            for item in self.stratum_report_tree.get_children():
                values = self.stratum_report_tree.item(item, 'values')
                text = self.stratum_report_tree.item(item, 'text')
                
                report_data.append({
                    'Stratum': text,
                    'Population': values[0],
                    'Mean_Risk': values[1],
                    'Risk_Weight': values[2],
                    'Sampled': values[3],
                    'Coverage_%': values[4],
                    'Allocation_Reason': values[5]
                })
            
            if report_data:
                df = pd.DataFrame(report_data)
                df.to_csv(stratum_filename, index=False)
            
            # Report text
            report_filename = os.path.join(self.results_dir, f"Sampling_Report_{timestamp}.txt")
            report = self.sampling_insights_text.get(1.0, tk.END)
            
            with open(report_filename, 'w') as f:
                f.write(report)
            
            messagebox.showinfo("Success", f"✓ All results exported to:\n{self.results_dir}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")
    
    # ===== VISUALIZATIONS =====
    
    def update_visualizations(self):
        """Generate charts"""
        if not self.comparison_results or 'risk_score' not in self.data.columns:
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            for ax in self.axes.flat:
                ax.clear()
            
            # Chart 1: Sample size comparison
            ax = self.axes[0, 0]
            methods = []
            sizes = []
            
            for method_key in ['traditional', 'risk_pps', 'hybrid']:
                if method_key in self.comparison_results:
                    display_name = {
                        'traditional': 'Traditional',
                        'risk_pps': 'Risk-PPS',
                        'hybrid': 'Hybrid'
                    }.get(method_key)
                    methods.append(display_name)
                    sizes.append(len(self.comparison_results[method_key]['sample']))
            
            ax.bar(methods, sizes, color=['skyblue', 'orange', 'lightcoral'])
            ax.set_ylabel('Sample Size')
            ax.set_title('Sample Size by Method')
            ax.grid(axis='y', alpha=0.3)
            
            # Chart 2: Risk distribution
            ax = self.axes[0, 1]
            ax.hist(self.data['risk_score'], bins=50, edgecolor='black', alpha=0.7, color='steelblue')
            ax.set_xlabel('Risk Score')
            ax.set_ylabel('Frequency')
            ax.set_title('Population Risk Score Distribution')
            ax.grid(alpha=0.3)
            
            # Chart 3: Strata coverage
            ax = self.axes[0, 2]
            coverage_data = []
            coverage_methods = []
            
            for method_key in ['traditional', 'risk_pps', 'hybrid']:
                if method_key in self.comparison_results:
                    info = self.comparison_results[method_key]['stratum_info']
                    covered = sum(1 for v in info.values() if v['sampled'] > 0)
                    coverage_pct = (covered / self.total_strata_count * 100) if self.total_strata_count > 0 else 0
                    
                    coverage_data.append(coverage_pct)
                    coverage_methods.append({
                        'traditional': 'Traditional',
                        'risk_pps': 'Risk-PPS',
                        'hybrid': 'Hybrid'
                    }.get(method_key))
            
            ax.bar(coverage_methods, coverage_data, color=['skyblue', 'orange', 'lightcoral'])
            ax.set_ylabel('Coverage %')
            ax.set_title('Stratum Coverage by Method')
            ax.set_ylim([0, 100])
            ax.grid(axis='y', alpha=0.3)
            
            # Chart 4: High-risk capture
            ax = self.axes[1, 0]
            high_risk_data = []
            high_risk_methods = []
            
            high_risk_total = len(self.data[self.data['risk_score'] > 0.7])
            
            for method_key in ['traditional', 'risk_pps', 'hybrid']:
                if method_key in self.comparison_results:
                    sample = self.comparison_results[method_key]['sample']
                    high_risk_captured = len(sample[sample['risk_score'] > 0.7])
                    capture_pct = (high_risk_captured / high_risk_total * 100) if high_risk_total > 0 else 0
                    
                    high_risk_data.append(capture_pct)
                    high_risk_methods.append({
                        'traditional': 'Traditional',
                        'risk_pps': 'Risk-PPS',
                        'hybrid': 'Hybrid'
                    }.get(method_key))
            
            ax.bar(high_risk_methods, high_risk_data, color=['skyblue', 'orange', 'lightcoral'])
            ax.set_ylabel('High-Risk Capture %')
            ax.set_title(f'High-Risk (>0.7) Record Capture')
            ax.set_ylim([0, 100])
            ax.grid(axis='y', alpha=0.3)
            
            # Chart 5: Average risk in sample
            ax = self.axes[1, 1]
            avg_risk_data = []
            avg_risk_methods = []
            
            for method_key in ['traditional', 'risk_pps', 'hybrid']:
                if method_key in self.comparison_results:
                    sample = self.comparison_results[method_key]['sample']
                    avg_risk = sample['risk_score'].mean()
                    
                    avg_risk_data.append(avg_risk)
                    avg_risk_methods.append({
                        'traditional': 'Traditional',
                        'risk_pps': 'Risk-PPS',
                        'hybrid': 'Hybrid'
                    }.get(method_key))
            
            ax.bar(avg_risk_methods, avg_risk_data, color=['skyblue', 'orange', 'lightcoral'])
            ax.set_ylabel('Average Risk Score')
            ax.set_title('Sample Risk Profile')
            ax.set_ylim([0, 1])
            ax.grid(axis='y', alpha=0.3)
            
            # Chart 6: Factors used
            ax = self.axes[1, 2]
            factor_labels = []
            factor_counts = []
            
            if self.risk_config['value']['enabled']:
                factor_labels.append('Value')
                factor_counts.append(1)
            if self.risk_config['aging']['enabled']:
                factor_labels.append('Aging')
                factor_counts.append(1)
            if self.risk_config['reason']['enabled']:
                factor_labels.append('Reason')
                factor_counts.append(1)
            
            factor_labels.extend(['Entity', 'Region', 'Product'])
            factor_counts.extend([1, 1, 1])
            
            colors = plt.cm.Set3(range(len(factor_labels)))
            ax.bar(factor_labels, factor_counts, color=colors)
            ax.set_ylabel('Active')
            ax.set_title('Risk Factors Used')
            ax.set_ylim([0, 1.5])
            
            self.fig.tight_layout()
            self.canvas.draw()
            
            messagebox.showinfo("Success", "Charts generated")
        except Exception as e:
            messagebox.showerror("Error", f"Chart generation failed: {str(e)}")

def main():
    root = tk.Tk()
    app = OMRCRiskBasedSamplingToolV3(root)
    root.mainloop()

if __name__ == '__main__':
    main()
