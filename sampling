#!/usr/bin/env python3
"""
OMRC Audit Sampling Tool - v8.4 FINAL
Complete Responsive Dashboard Edition with Reference Code UI Patterns

Key Features:
✓ Professional responsive grid-based layout
✓ Clean UI using reference code patterns
✓ 5-tab interface (Data, Risk, Sampling, Coverage, Visualizations)
✓ Advanced statistical sampling (3 methods)
✓ ISA 530 / AU-C 530 compliance
✓ Production-ready code

Author: OMRC Compliance Team
Version: 8.4
Last Updated: December 10, 2025
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, Toplevel, Listbox, MULTIPLE
import pandas as pd
import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import math
from datetime import datetime
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import seaborn as sns
import warnings

warnings.filterwarnings('ignore')
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")


class OMRCRiskBasedSamplingTool:
    """Main application class - Responsive Grid-Based Layout"""
    
    def __init__(self, root, out_dir_path):
        self.root = root
        self.root.title("OMRC Audit Sampling Tool v8.4")
        self.root.geometry("1600x1000")
        self.root.minsize(1200, 800)
        self.root.configure(bg="#0F1419")
        
        # Data storage
        self.data = None
        self.comparison_results = {}
        self.out_of_scope_data = {}
        self.missed_strata = {}
        self.method_coverage_data = {}
        self.total_strata_count = 0
        
        # Risk scores
        self.mandatory_risk_scores = {'entity': {}, 'region': {}, 'product': {}}
        self.additional_risk_weights = {}
        self.selected_additional_columns = []
        
        # Results directory
        self.results_dir = os.path.join(out_dir_path, "OMRC_Results")
        os.makedirs(self.results_dir, exist_ok=True)
        
        self.create_widgets()
    
    # ========== UTILITY FUNCTIONS ==========
    
    def safe_float_conversion(self, value, default=0.0):
        """Safely convert value to float"""
        try:
            if isinstance(value, str):
                value = value.strip()
                if value == '': 
                    return default
            return float(value)
        except:
            return default
    
    def safe_int_conversion(self, value, default=0):
        """Safely convert value to int"""
        try:
            if isinstance(value, str):
                value = value.strip()
                if value == '': 
                    return default
            return int(float(value))
        except:
            return default
    
    def ensure_numeric_column(self, df, column_name):
        """Ensure column is numeric"""
        if column_name in df.columns:
            df[column_name] = pd.to_numeric(df[column_name], errors='coerce')
        return df
    
    def safe_sort_unique(self, series):
        """Safely get sorted unique values"""
        try:
            unique_vals = series.dropna().unique()
            try:
                return sorted(unique_vals)
            except:
                return sorted([str(val) for val in unique_vals])
        except:
            return list(series.dropna().unique())
    
    # ========== WIDGET CREATION (RESPONSIVE GRID) ==========
    
    def create_widgets(self):
        """Create main notebook with 5 tabs"""
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        self.tab1 = ttk.Frame(notebook)
        notebook.add(self.tab1, text="1. Data & Configuration")
        
        self.tab2 = ttk.Frame(notebook)
        notebook.add(self.tab2, text="2. Risk Calculation")
        
        self.tab3 = ttk.Frame(notebook)
        notebook.add(self.tab3, text="3. Sampling & Results")
        
        self.tab4 = ttk.Frame(notebook)
        notebook.add(self.tab4, text="4. Coverage Analysis")
        
        self.tab5 = ttk.Frame(notebook)
        notebook.add(self.tab5, text="5. Visualizations")
        
        self.create_tab1_widgets()
        self.create_tab2_widgets()
        self.create_tab3_widgets()
        self.create_tab4_widgets()
        self.create_tab5_widgets()
    
    def create_tab1_widgets(self):
        """Tab 1: Data Loading & Configuration - Responsive Grid Layout"""
        
        # Row 0: Data Loading Frame
        data_frame = ttk.LabelFrame(self.tab1, text="Data Loading", padding="10")
        data_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Button(data_frame, text="Load Data", 
                   command=self.load_data).grid(row=0, column=0, padx=5)
        ttk.Button(data_frame, text="Generate Sample", 
                   command=self.generate_sample_data).grid(row=0, column=1, padx=5)
        
        self.data_label = ttk.Label(data_frame, text="No data loaded")
        self.data_label.grid(row=1, column=0, columnspan=2, pady=5, sticky=tk.W)
        
        # Row 1: Mandatory Columns
        mandatory_frame = ttk.LabelFrame(self.tab1, text="MANDATORY COLUMNS", padding="10")
        mandatory_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Label(mandatory_frame, text="Legal Entity:*", 
                  font=('Arial', 9, 'bold')).grid(row=0, column=0, sticky=tk.W)
        self.entity_col_var = tk.StringVar(value="legal_entity")
        self.entity_col_combo = ttk.Combobox(mandatory_frame, 
                                             textvariable=self.entity_col_var, width=25)
        self.entity_col_combo.grid(row=0, column=1, padx=5, sticky=tk.W)
        
        ttk.Label(mandatory_frame, text="Region:*", 
                  font=('Arial', 9, 'bold')).grid(row=0, column=2, sticky=tk.W, padx=(20,0))
        self.region_col_var = tk.StringVar(value="region")
        self.region_col_combo = ttk.Combobox(mandatory_frame, 
                                             textvariable=self.region_col_var, width=25)
        self.region_col_combo.grid(row=0, column=3, padx=5, sticky=tk.W)
        
        ttk.Label(mandatory_frame, text="Product:*", 
                  font=('Arial', 9, 'bold')).grid(row=1, column=0, sticky=tk.W)
        self.product_col_var = tk.StringVar(value="product_type")
        self.product_col_combo = ttk.Combobox(mandatory_frame, 
                                              textvariable=self.product_col_var, width=25)
        self.product_col_combo.grid(row=1, column=1, padx=5, sticky=tk.W)
        
        # Row 2: Additional Columns
        additional_frame = ttk.LabelFrame(self.tab1, text="ADDITIONAL COLUMNS", padding="10")
        additional_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        self.additional_cols_label = ttk.Label(additional_frame, 
                                               text="No additional columns", 
                                               foreground='gray')
        self.additional_cols_label.grid(row=0, column=0, sticky=tk.W, pady=5)
        
        ttk.Button(additional_frame, text="Select Additional Columns", 
                   command=self.open_column_selector).grid(row=1, column=0, pady=5, sticky=tk.W)
        
        # Row 3: Results Info
        results_info = ttk.LabelFrame(self.tab1, text="Export", padding="10")
        results_info.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Label(results_info, text=f"Auto-Export: {self.results_dir}", 
                  font=('Arial', 9), foreground='blue').grid(row=0, column=0, sticky=tk.W)
        
        # Row 4: Data Preview (Expandable)
        preview_frame = ttk.LabelFrame(self.tab1, text="Data Preview", padding="10")
        preview_frame.grid(row=4, column=0, columnspan=2, 
                          sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        self.tree = ttk.Treeview(preview_frame)
        scrollbar_y = ttk.Scrollbar(preview_frame, orient="vertical", command=self.tree.yview)
        scrollbar_x = ttk.Scrollbar(preview_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
        scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        # Configure grid weights for responsiveness
        self.tab1.rowconfigure(4, weight=1)
        self.tab1.columnconfigure(0, weight=1)
        preview_frame.rowconfigure(0, weight=1)
        preview_frame.columnconfigure(0, weight=1)
    
    def create_tab2_widgets(self):
        """Tab 2: Risk Calculation - Two Column Layout"""
        
        main_frame = ttk.Frame(self.tab2)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # LEFT: Risk calculation button + insights
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))
        
        calc_frame = ttk.LabelFrame(left_frame, text="Risk Calculation", padding="10")
        calc_frame.pack(fill='x', pady=(0, 10))
        
        ttk.Button(calc_frame, text="Calculate Risk Scores", 
                   command=self.calculate_statistical_risk_scores).pack(side='left', padx=5)
        
        self.risk_calc_label = ttk.Label(calc_frame, text="Not calculated")
        self.risk_calc_label.pack(side='left', padx=10)
        
        # Population insights
        insights_frame = ttk.LabelFrame(left_frame, text="Population Insights", padding="10")
        insights_frame.pack(fill='both', expand=True)
        
        self.insights_text_tab2 = tk.Text(insights_frame, height=35, width=60, 
                                          font=('Courier', 9))
        insights_scrollbar = ttk.Scrollbar(insights_frame, orient="vertical", 
                                          command=self.insights_text_tab2.yview)
        self.insights_text_tab2.configure(yscrollcommand=insights_scrollbar.set)
        
        self.insights_text_tab2.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        insights_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # RIGHT: Risk breakdown (tabbed)
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(row=0, column=1, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        risk_notebook = ttk.Notebook(right_frame)
        risk_notebook.pack(fill='both', expand=True)
        
        # Mandatory columns tab
        mandatory_frame = ttk.Frame(risk_notebook)
        risk_notebook.add(mandatory_frame, text="Mandatory Columns")
        
        self.mandatory_tree = ttk.Treeview(mandatory_frame, 
                                          columns=("Column", "Item", "Count", "Freq", "Risk"), 
                                          show="tree headings")
        for col in ["Column", "Item", "Count", "Freq", "Risk"]:
            self.mandatory_tree.heading(col, text=col)
            self.mandatory_tree.column(col, width=120)
        
        scrollbar = ttk.Scrollbar(mandatory_frame, orient="vertical", 
                                 command=self.mandatory_tree.yview)
        self.mandatory_tree.configure(yscrollcommand=scrollbar.set)
        self.mandatory_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Additional columns tab
        additional_frame = ttk.Frame(risk_notebook)
        risk_notebook.add(additional_frame, text="Additional Columns")
        
        self.additional_tree = ttk.Treeview(additional_frame, 
                                           columns=("Column", "Item", "Count", "Freq", "Risk"), 
                                           show="tree headings")
        for col in ["Column", "Item", "Count", "Freq", "Risk"]:
            self.additional_tree.heading(col, text=col)
            self.additional_tree.column(col, width=120)
        
        scrollbar2 = ttk.Scrollbar(additional_frame, orient="vertical", 
                                  command=self.additional_tree.yview)
        self.additional_tree.configure(yscrollcommand=scrollbar2.set)
        self.additional_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar2.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Configure weights
        main_frame.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=2)
    
    def create_tab3_widgets(self):
        """Tab 3: Sampling & Results"""
        
        # Row 0: Parameters
        params_frame = ttk.LabelFrame(self.tab3, text="Parameters", padding="10")
        params_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Label(params_frame, text="Confidence:").grid(row=0, column=0, sticky=tk.W)
        self.confidence_var = tk.StringVar(value="95")
        ttk.Combobox(params_frame, textvariable=self.confidence_var,
                    values=["90", "95", "99"], width=10).grid(row=0, column=1, padx=5)
        
        ttk.Label(params_frame, text="Margin:").grid(row=0, column=2, sticky=tk.W, padx=(20,0))
        self.margin_var = tk.StringVar(value="0.05")
        ttk.Entry(params_frame, textvariable=self.margin_var, width=10).grid(row=0, column=3, padx=5)
        
        ttk.Label(params_frame, text="Error Rate (p):").grid(row=1, column=0, sticky=tk.W)
        self.risk_var = tk.StringVar(value="0.15")
        ttk.Entry(params_frame, textvariable=self.risk_var, width=10).grid(row=1, column=1, padx=5)
        
        # Row 1: Methods
        methods_frame = ttk.LabelFrame(self.tab3, text="Methods", padding="10")
        methods_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        self.method_vars = {}
        for i, (name, key) in enumerate([
            ('Traditional Random', 'traditional'),
            ('Risk-Based Stratified (Neyman)', 'risk_based'),
            ('Enhanced Hybrid (Power Analysis)', 'hybrid')
        ]):
            var = tk.BooleanVar(value=True)
            self.method_vars[key] = var
            ttk.Checkbutton(methods_frame, text=name, variable=var).grid(row=i, column=0, 
                                                                          sticky=tk.W, padx=20, pady=5)
        
        ttk.Button(methods_frame, text="Generate & Compare Samples", 
                   command=self.generate_comparison_samples).grid(row=3, column=0, 
                                                                  pady=20, sticky=(tk.W, tk.E), padx=20)
        
        # Row 2: Results (Expandable)
        results_frame = ttk.LabelFrame(self.tab3, text="Results & Insights", padding="10")
        results_frame.grid(row=2, column=0, columnspan=2, 
                          sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        results_notebook = ttk.Notebook(results_frame)
        results_notebook.pack(fill='both', expand=True)
        
        # Summary tab
        summary_frame = ttk.Frame(results_notebook)
        results_notebook.add(summary_frame, text="Summary")
        
        self.summary_tree = ttk.Treeview(summary_frame, 
                                        columns=("Size", "High_Risk", "Coverage", "Avg_Risk", "Strata"), 
                                        show="tree headings")
        self.summary_tree.heading("#0", text="Method")
        for col in ["Size", "High_Risk", "Coverage", "Avg_Risk", "Strata"]:
            self.summary_tree.heading(col, text=col)
            self.summary_tree.column(col, width=100)
        
        scrollbar = ttk.Scrollbar(summary_frame, orient="vertical", 
                                 command=self.summary_tree.yview)
        self.summary_tree.configure(yscrollcommand=scrollbar.set)
        self.summary_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Insights tab
        insights_frame = ttk.Frame(results_notebook)
        results_notebook.add(insights_frame, text="Insights")
        
        self.insights_text = tk.Text(insights_frame, height=20, width=80, font=('Courier', 10))
        insights_scrollbar = ttk.Scrollbar(insights_frame, orient="vertical", 
                                          command=self.insights_text.yview)
        self.insights_text.configure(yscrollcommand=insights_scrollbar.set)
        self.insights_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        insights_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Export buttons
        export_frame = ttk.Frame(results_frame)
        export_frame.pack(fill='x', pady=5)
        
        ttk.Button(export_frame, text="Export Samples", 
                   command=self.export_samples).pack(side='left', padx=5)
        ttk.Button(export_frame, text="Export Out-of-Scope", 
                   command=self.export_out_of_scope).pack(side='left', padx=5)
        ttk.Button(export_frame, text="Export Report", 
                   command=self.export_report).pack(side='left', padx=5)
        ttk.Button(export_frame, text="Export All", 
                   command=self.export_all_results).pack(side='left', padx=5)
        
        # Configure weights
        self.tab3.rowconfigure(2, weight=1)
        self.tab3.columnconfigure(0, weight=1)
    
    def create_tab4_widgets(self):
        """Tab 4: Coverage Analysis"""
        
        self.coverage_notebook = ttk.Notebook(self.tab4)
        self.coverage_notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        self.method_coverage_tabs = {}
        
        methods = [
            ('Traditional Random', 'traditional'),
            ('Risk-Based Stratified', 'risk_based'),
            ('Enhanced Hybrid', 'hybrid')
        ]
        
        for display_name, method_key in methods:
            method_frame = ttk.Frame(self.coverage_notebook)
            self.coverage_notebook.add(method_frame, text=display_name)
            
            sub_notebook = ttk.Notebook(method_frame)
            sub_notebook.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Missed strata tab
            missed_frame = ttk.Frame(sub_notebook)
            sub_notebook.add(missed_frame, text="Missed Strata")
            
            missed_tree = ttk.Treeview(missed_frame, 
                                      columns=("Population", "Risk", "Reason"), 
                                      show="tree headings")
            missed_tree.heading("#0", text="Stratum")
            missed_tree.heading("Population", text="Population")
            missed_tree.heading("Risk", text="Avg Risk")
            missed_tree.heading("Reason", text="Reason")
            
            missed_tree.column("#0", width=400)
            for col in ["Population", "Risk", "Reason"]:
                missed_tree.column(col, width=120)
            
            missed_scrollbar_y = ttk.Scrollbar(missed_frame, orient="vertical", 
                                              command=missed_tree.yview)
            missed_scrollbar_x = ttk.Scrollbar(missed_frame, orient="horizontal", 
                                              command=missed_tree.xview)
            missed_tree.configure(yscrollcommand=missed_scrollbar_y.set, 
                                 xscrollcommand=missed_scrollbar_x.set)
            
            missed_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
            missed_scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
            missed_scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
            
            missed_frame.rowconfigure(0, weight=1)
            missed_frame.columnconfigure(0, weight=1)
            
            # All strata tab
            all_frame = ttk.Frame(sub_notebook)
            sub_notebook.add(all_frame, text="All Strata")
            
            all_tree = ttk.Treeview(all_frame, 
                                   columns=("Population", "Sampled", "Coverage", "Risk"), 
                                   show="tree headings")
            all_tree.heading("#0", text="Stratum")
            all_tree.heading("Population", text="Population")
            all_tree.heading("Sampled", text="Sampled")
            all_tree.heading("Coverage", text="Coverage %")
            all_tree.heading("Risk", text="Avg Risk")
            
            all_tree.column("#0", width=400)
            for col in ["Population", "Sampled", "Coverage", "Risk"]:
                all_tree.column(col, width=100)
            
            all_scrollbar_y = ttk.Scrollbar(all_frame, orient="vertical", 
                                           command=all_tree.yview)
            all_scrollbar_x = ttk.Scrollbar(all_frame, orient="horizontal", 
                                           command=all_tree.xview)
            all_tree.configure(yscrollcommand=all_scrollbar_y.set, 
                              xscrollcommand=all_scrollbar_x.set)
            
            all_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
            all_scrollbar_y.grid(row=0, column=1, sticky=(tk.N, tk.S))
            all_scrollbar_x.grid(row=1, column=0, sticky=(tk.W, tk.E))
            
            all_frame.rowconfigure(0, weight=1)
            all_frame.columnconfigure(0, weight=1)
            
            self.method_coverage_tabs[method_key] = {
                'missed_tree': missed_tree,
                'all_tree': all_tree
            }
    
    def create_tab5_widgets(self):
        """Tab 5: Visualizations"""
        
        control_frame = ttk.LabelFrame(self.tab5, text="Controls", padding="10")
        control_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Button(control_frame, text="Generate Charts", 
                   command=self.update_visualizations).grid(row=0, column=0, padx=5)
        
        viz_frame = ttk.LabelFrame(self.tab5, text="Charts", padding="10")
        viz_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        self.fig, self.axes = plt.subplots(2, 3, figsize=(18, 12))
        self.fig.tight_layout(pad=3.0)
        
        self.canvas = FigureCanvasTkAgg(self.fig, master=viz_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        self.tab5.rowconfigure(1, weight=1)
        self.tab5.columnconfigure(0, weight=1)
        viz_frame.rowconfigure(0, weight=1)
        viz_frame.columnconfigure(0, weight=1)
    
    # ========== DATA LOADING ==========
    
    def load_data(self):
        """Load data from CSV or Excel"""
        file_path = filedialog.askopenfilename(
            title="Select Data File",
            filetypes=[("CSV", "*.csv"), ("Excel", "*.xlsx"), ("All", "*.*")]
        )
        
        if file_path:
            try:
                if file_path.endswith('.csv'):
                    df = pd.read_csv(file_path)
                else:
                    df = pd.read_excel(file_path)
                
                self.data = df
                self.update_column_dropdowns()
                self.update_data_preview()
                self.data_label.config(text=f"Loaded {len(df):,} records")
                messagebox.showinfo("Success", f"Loaded {len(df):,} records")
            except Exception as e:
                messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def generate_sample_data(self):
        """Generate demo data"""
        try:
            np.random.seed(42)
            n = 10000
            
            entity_regions = {
                'HBAP': ['LN', 'AU', 'IN', 'PA', 'HK', 'SG'],
                'HBEU': ['LN', 'PA', 'FR', 'DE', 'IT', 'CH'],
                'HBUS': ['NY', 'CA', 'TX', 'IL', 'FL']
            }
            
            products = ['Cash_Bonds', 'Equities', 'IRD', 'FX_Derivatives', 
                       'ABS_MBS', 'Structured_Products', 'Repo', 'Commodities']
            
            reason_codes = ['Price_Mismatch', 'Model_Error', 'Data_Quality', 'Process_Delay',
                           'System_Error', 'Manual_Override', 'Counterparty_Issue', 'Settlement_Delay']
            
            entities = []
            regions = []
            entity_probs = {'HBAP': 0.45, 'HBEU': 0.35, 'HBUS': 0.20}
            
            for _ in range(n):
                entity = np.random.choice(list(entity_regions.keys()), p=list(entity_probs.values()))
                region = np.random.choice(entity_regions[entity])
                entities.append(entity)
                regions.append(region)
            
            data = {
                'exception_id': range(1, n + 1),
                'legal_entity': entities,
                'region': regions,
                'product_type': np.random.choice(products, n, 
                                               p=[0.25, 0.20, 0.15, 0.12, 0.08, 0.06, 0.08, 0.06]),
                'reason_code': np.random.choice(reason_codes, n,
                                              p=[0.25, 0.15, 0.15, 0.10, 0.10, 0.08, 0.10, 0.07]),
                'desk_id': [f"DESK_{i:02d}" for i in np.random.randint(1, 31, n)],
                'trade_value': np.random.lognormal(15, 1.5, n),
                'aging_days': np.random.exponential(8, n).astype(int)
            }
            
            df = pd.DataFrame(data)
            
            self.data = df
            self.update_column_dropdowns()
            self.update_data_preview()
            self.data_label.config(text=f"Generated {len(df):,} records")
            messagebox.showinfo("Success", f"Generated {len(df):,} records")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def update_column_dropdowns(self):
        """Update dropdowns with column names"""
        if self.data is None:
            return
        
        columns = list(self.data.columns)
        
        self.entity_col_combo['values'] = columns
        self.region_col_combo['values'] = columns
        self.product_col_combo['values'] = columns
        
        for col in self.data.columns:
            col_lower = col.lower()
            if 'entity' in col_lower or 'legal' in col_lower:
                self.entity_col_var.set(col)
            elif 'region' in col_lower or 'hub' in col_lower:
                self.region_col_var.set(col)
            elif 'product' in col_lower or 'type' in col_lower:
                self.product_col_var.set(col)
    
    def update_data_preview(self):
        """Update tree view preview"""
        if self.data is None:
            return
        
        for item in self.tree.get_children():
            self.tree.delete(item)
        
        display_cols = list(self.data.columns)
        
        self.tree["columns"] = display_cols
        self.tree["show"] = "headings"
        
        for col in display_cols:
            self.tree.heading(col, text=col.replace('_', ' ').title())
            self.tree.column(col, width=120)
        
        for _, row in self.data.head(100).iterrows():
            values = [str(row.get(col, '')) for col in display_cols]
            self.tree.insert("", "end", values=values)
    
    def open_column_selector(self):
        """Open column selection dialog"""
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        mandatory_cols = [self.entity_col_var.get(), self.region_col_var.get(), 
                         self.product_col_var.get()]
        available_cols = [col for col in self.data.columns if col not in mandatory_cols]
        
        dialog = Toplevel(self.root)
        dialog.title("Select Additional Columns")
        dialog.geometry("500x400")
        
        ttk.Label(dialog, text="Select additional columns:", 
                  font=('Arial', 10, 'bold')).pack(pady=10)
        ttk.Label(dialog, text="(Ctrl/Cmd for multiple)", 
                  font=('Arial', 9), foreground='gray').pack()
        
        frame = ttk.Frame(dialog)
        frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        scrollbar = ttk.Scrollbar(frame)
        scrollbar.pack(side='right', fill='y')
        
        listbox = Listbox(frame, selectmode=MULTIPLE, yscrollcommand=scrollbar.set, 
                         font=('Arial', 10))
        listbox.pack(side='left', fill='both', expand=True)
        scrollbar.config(command=listbox.yview)
        
        for col in available_cols:
            listbox.insert('end', col)
        
        for i, col in enumerate(available_cols):
            if col in self.selected_additional_columns:
                listbox.selection_set(i)
        
        def confirm():
            selected = listbox.curselection()
            self.selected_additional_columns = [available_cols[i] for i in selected]
            
            if self.selected_additional_columns:
                display = f"Selected {len(self.selected_additional_columns)}: " \
                         f"{', '.join(self.selected_additional_columns[:3])}" \
                         f"{'...' if len(self.selected_additional_columns) > 3 else ''}"
                self.additional_cols_label.config(text=display, foreground='blue')
            else:
                self.additional_cols_label.config(text="No additional columns", foreground='gray')
            dialog.destroy()
        
        ttk.Button(dialog, text="Confirm", command=confirm).pack(pady=10)
    
    # ========== RISK CALCULATION ==========
    
    def calculate_statistical_weights(self, data, column):
        """Calculate statistical weights for column"""
        counts = data[column].value_counts()
        total = len(data)
        frequencies = counts / total
        
        if len(frequencies) > 1:
            min_f = frequencies.min()
            max_f = frequencies.max()
            if max_f > min_f:
                weights = 0.1 + 0.9 * (frequencies - min_f) / (max_f - min_f)
            else:
                weights = pd.Series(0.5, index=frequencies.index)
        else:
            weights = pd.Series(0.5, index=frequencies.index)
        
        return weights.to_dict(), frequencies.to_dict(), counts.to_dict()
    
    def calculate_statistical_risk_scores(self):
        """Calculate risk scores"""
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        try:
            entity_col = self.entity_col_var.get()
            region_col = self.region_col_var.get()
            product_col = self.product_col_var.get()
            
            required = [entity_col, region_col, product_col]
            missing = [col for col in required if col not in self.data.columns]
            
            if missing:
                messagebox.showerror("Error", f"Missing: {missing}")
                return
            
            # Calculate weights for mandatory columns
            self.mandatory_risk_scores['entity'] = {'weights': {}, 'frequencies': {}, 'counts': {}}
            self.mandatory_risk_scores['region'] = {'weights': {}, 'frequencies': {}, 'counts': {}}
            self.mandatory_risk_scores['product'] = {'weights': {}, 'frequencies': {}, 'counts': {}}
            
            for key, col in [('entity', entity_col), ('region', region_col), ('product', product_col)]:
                w, f, c = self.calculate_statistical_weights(self.data, col)
                self.mandatory_risk_scores[key]['weights'] = w
                self.mandatory_risk_scores[key]['frequencies'] = f
                self.mandatory_risk_scores[key]['counts'] = c
            
            # Calculate for additional columns
            self.additional_risk_weights = {}
            for col in self.selected_additional_columns:
                if col in self.data.columns:
                    w, f, c = self.calculate_statistical_weights(self.data, col)
                    self.additional_risk_weights[col] = {
                        'weights': w,
                        'frequencies': f,
                        'counts': c
                    }
            
            self.calculate_composite_risk_score()
            self.update_risk_displays()
            self.update_population_insights()
            self.risk_calc_label.config(
                text=f"Calculated ({3 + len(self.selected_additional_columns)} dimensions)"
            )
            
            messagebox.showinfo("Success", 
                f"Risk scores calculated for {3 + len(self.selected_additional_columns)} dimensions")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def calculate_composite_risk_score(self):
        """Calculate composite risk score"""
        entity_col = self.entity_col_var.get()
        region_col = self.region_col_var.get()
        product_col = self.product_col_var.get()
        
        self.data['entity_risk'] = self.data[entity_col].map(
            self.mandatory_risk_scores['entity']['weights']
        ).fillna(0.5)
        
        self.data['region_risk'] = self.data[region_col].map(
            self.mandatory_risk_scores['region']['weights']
        ).fillna(0.5)
        
        self.data['product_risk'] = self.data[product_col].map(
            self.mandatory_risk_scores['product']['weights']
        ).fillna(0.5)
        
        for col in ['entity_risk', 'region_risk', 'product_risk']:
            self.data = self.ensure_numeric_column(self.data, col)
        
        additional_risk_cols = []
        for col in self.selected_additional_columns:
            if col in self.additional_risk_weights:
                risk_col = f'{col}_risk'
                self.data[risk_col] = self.data[col].map(
                    self.additional_risk_weights[col]['weights']
                ).fillna(0.5)
                self.data = self.ensure_numeric_column(self.data, risk_col)
                additional_risk_cols.append(risk_col)
        
        total_dims = 3 + len(additional_risk_cols)
        weight = 1.0 / total_dims
        
        risk_components = [
            weight * self.data['entity_risk'],
            weight * self.data['region_risk'],
            weight * self.data['product_risk']
        ]
        
        for risk_col in additional_risk_cols:
            risk_components.append(weight * self.data[risk_col])
        
        self.data['risk_score'] = sum(risk_components)
        self.data = self.ensure_numeric_column(self.data, 'risk_score')
        self.data['risk_score'] = np.clip(self.data['risk_score'], 0.01, 1.0)
        
        all_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
        self.data['stratum'] = self.data[all_cols].apply(
            lambda x: '_'.join(x.astype(str)), axis=1
        )
        
        self.total_strata_count = len(self.data.groupby(all_cols))
    
    def update_population_insights(self):
        """Update population insights text"""
        self.insights_text_tab2.delete(1.0, tk.END)
        
        if self.data is None or 'risk_score' not in self.data.columns:
            self.insights_text_tab2.insert(1.0, "Calculate risk scores first")
            return
        
        entity_col = self.entity_col_var.get()
        region_col = self.region_col_var.get()
        product_col = self.product_col_var.get()
        all_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
        
        strata = self.data.groupby(all_cols).size()
        total_strata = len(strata)
        self.total_strata_count = total_strata
        
        unique_entities = self.data[entity_col].nunique()
        unique_regions = self.data[region_col].nunique()
        unique_products = self.data[product_col].nunique()
        
        high_risk = len(self.data[self.data['risk_score'] > 0.7])
        medium_risk = len(self.data[(self.data['risk_score'] >= 0.3) & (self.data['risk_score'] <= 0.7)])
        low_risk = len(self.data[self.data['risk_score'] < 0.3])
        
        insights = f"""=== POPULATION INSIGHTS ===
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

STRATIFICATION COMPLEXITY:
Total Population: {len(self.data):,}
Total Unique Strata: {total_strata:,}

Dimensions Used: {len(all_cols)}
 • Mandatory (3): Entity, Region, Product
 • Additional ({len(self.selected_additional_columns)}): {', '.join(self.selected_additional_columns) if self.selected_additional_columns else 'None'}

DIMENSION BREAKDOWN:
Legal Entities: {unique_entities} unique values
Regions: {unique_regions} unique values
Products: {unique_products} unique values

ACTUAL STRATA: {total_strata:,}

RISK DISTRIBUTION:
High-Risk (>0.7):   {high_risk:,} ({high_risk/len(self.data)*100:.1f}%)
Medium-Risk (0.3-0.7): {medium_risk:,} ({medium_risk/len(self.data)*100:.1f}%)
Low-Risk (<0.3):    {low_risk:,} ({low_risk/len(self.data)*100:.1f}%)

STRATUM STATISTICS:
Largest Stratum:  {strata.max():,} records
Smallest Stratum: {strata.min():,} records
Average Stratum:  {strata.mean():.1f} records
Median Stratum:   {strata.median():.1f} records

STATUS: ✓ Ready for sampling analysis
"""
        
        self.insights_text_tab2.insert(1.0, insights)
    
    def update_risk_displays(self):
        """Update risk breakdown displays"""
        for item in self.mandatory_tree.get_children():
            self.mandatory_tree.delete(item)
        for item in self.additional_tree.get_children():
            self.additional_tree.delete(item)
        
        entity_col = self.entity_col_var.get()
        region_col = self.region_col_var.get()
        product_col = self.product_col_var.get()
        
        for col_name, display_name in [(entity_col, 'Legal Entity'), 
                                        (region_col, 'Region'), 
                                        (product_col, 'Product')]:
            risk_key = 'entity' if col_name == entity_col else ('region' if col_name == region_col else 'product')
            parent = self.mandatory_tree.insert("", "end", text="", values=(display_name, "", "", "", ""))
            
            for item in self.safe_sort_unique(self.data[col_name]):
                count = self.mandatory_risk_scores[risk_key]['counts'].get(item, 0)
                freq = self.mandatory_risk_scores[risk_key]['frequencies'].get(item, 0) * 100
                risk = self.mandatory_risk_scores[risk_key]['weights'].get(item, 0.5)
                
                self.mandatory_tree.insert(parent, "end", text="", values=(
                    "", str(item), f"{count:,}", f"{freq:.2f}%", f"{risk:.4f}"
                ))
        
        for col in self.selected_additional_columns:
            if col in self.additional_risk_weights:
                parent = self.additional_tree.insert("", "end", text="", values=(col, "", "", "", ""))
                
                for item in self.safe_sort_unique(self.data[col]):
                    count = self.additional_risk_weights[col]['counts'].get(item, 0)
                    freq = self.additional_risk_weights[col]['frequencies'].get(item, 0) * 100
                    risk = self.additional_risk_weights[col]['weights'].get(item, 0.5)
                    
                    self.additional_tree.insert(parent, "end", text="", values=(
                        "", str(item), f"{count:,}", f"{freq:.2f}%", f"{risk:.4f}"
                    ))
    
    # ========== SAMPLING METHODS ==========
    
    def calculate_power_analysis_sample_size(self, confidence=95, margin=0.05, p=0.15):
        """Calculate sample size using power analysis"""
        z_scores = {90: 1.645, 95: 1.96, 99: 2.576}
        z_alpha = z_scores.get(confidence, 1.96)
        z_beta = 1.28
        
        q = 1 - p
        n_power = ((z_alpha * math.sqrt(2 * p * q)) + (z_beta * math.sqrt(p * q + p * q)))**2 / (margin**2)
        
        N = len(self.data)
        if N > 0 and n_power > 0:
            n_adj = n_power / (1 + (n_power - 1) / N)
        else:
            n_adj = n_power
        
        return max(1, math.ceil(n_adj * 1.3))
    
    def traditional_sampling(self, data, sample_size):
        """Traditional random sampling"""
        sample_size = self.safe_int_conversion(sample_size, 100)
        
        if sample_size >= len(data):
            return data.copy()
        
        return data.sample(n=sample_size, random_state=42)
    
    def risk_based_sampling(self, data, target_size):
        """Risk-based stratified sampling with Neyman allocation"""
        target_size = self.safe_int_conversion(target_size, 100)
        data = self.ensure_numeric_column(data.copy(), 'risk_score')
        
        entity_col = self.entity_col_var.get()
        region_col = self.region_col_var.get()
        product_col = self.product_col_var.get()
        all_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
        
        if not all(col in data.columns for col in all_cols):
            return self.traditional_sampling(data, target_size)
        
        strata_data = data.groupby(all_cols, observed=True)
        
        stratum_allocations = {}
        total_weighted = 0
        
        # Neyman allocation: weight = N_h * S_h * R_h
        for name, group in strata_data:
            N_h = len(group)
            s_h = group['risk_score'].std() if len(group) > 1 else 0.5
            r_h = group['risk_score'].mean()
            weight = N_h * s_h * r_h
            stratum_allocations[name] = {'population': N_h, 'weight': weight, 'group': group}
            total_weighted += weight
        
        # Allocate samples
        stratum_samples = {}
        for name, details in stratum_allocations.items():
            if total_weighted > 0:
                n_h = max(1, int((details['weight'] / total_weighted) * target_size))
            else:
                n_h = 1
            n_h = min(n_h, details['population'])
            stratum_samples[name] = n_h
        
        # Collect samples
        samples = []
        for name, n_h in stratum_samples.items():
            group = stratum_allocations[name]['group']
            if n_h >= len(group):
                samples.append(group)
            else:
                samples.append(group.sample(n=n_h, random_state=42))
        
        sample = pd.concat(samples, ignore_index=True)
        return sample
    
    def hybrid_sampling(self, data, target_size):
        """Enhanced hybrid sampling"""
        target_size = self.safe_int_conversion(target_size, 100)
        data = self.ensure_numeric_column(data.copy(), 'risk_score')
        
        # Split by risk level
        high_risk_data = data[data['risk_score'] > 0.7]
        medium_risk_data = data[(data['risk_score'] >= 0.3) & (data['risk_score'] <= 0.7)]
        low_risk_data = data[data['risk_score'] < 0.3]
        
        if len(high_risk_data) > 0:
            high_sample_size = max(1, int(target_size * 0.3))
            high_sample = high_risk_data.sample(n=min(high_sample_size, len(high_risk_data)), random_state=42)
        else:
            high_sample = pd.DataFrame()
        
        remaining_size = target_size - len(high_sample)
        
        if len(medium_risk_data) > 0:
            med_sample_size = max(1, int(remaining_size * 0.5))
            med_sample = medium_risk_data.sample(n=min(med_sample_size, len(medium_risk_data)), random_state=42)
        else:
            med_sample = pd.DataFrame()
        
        remaining_size -= len(med_sample)
        
        if len(low_risk_data) > 0 and remaining_size > 0:
            low_sample = low_risk_data.sample(n=min(remaining_size, len(low_risk_data)), random_state=42)
        else:
            low_sample = pd.DataFrame()
        
        return pd.concat([high_sample, med_sample, low_sample], ignore_index=True)
    
    def generate_comparison_samples(self):
        """Generate samples using all selected methods"""
        if self.data is None:
            messagebox.showerror("Error", "Load data first")
            return
        
        if 'risk_score' not in self.data.columns:
            messagebox.showerror("Error", "Calculate risk scores first")
            return
        
        try:
            confidence = self.safe_int_conversion(self.confidence_var.get(), 95)
            margin = self.safe_float_conversion(self.margin_var.get(), 0.05)
            p = self.safe_float_conversion(self.risk_var.get(), 0.15)
            
            target_size = self.calculate_power_analysis_sample_size(confidence, margin, p)
            
            # Generate samples
            self.comparison_results = {}
            
            if self.method_vars['traditional'].get():
                trad_sample = self.traditional_sampling(self.data, target_size)
                self.comparison_results['traditional'] = {
                    'sample': trad_sample,
                    'size': len(trad_sample),
                    'high_risk_count': len(trad_sample[trad_sample['risk_score'] > 0.7]),
                    'avg_risk': trad_sample['risk_score'].mean()
                }
            
            if self.method_vars['risk_based'].get():
                risk_sample = self.risk_based_sampling(self.data, target_size)
                self.comparison_results['risk_based'] = {
                    'sample': risk_sample,
                    'size': len(risk_sample),
                    'high_risk_count': len(risk_sample[risk_sample['risk_score'] > 0.7]),
                    'avg_risk': risk_sample['risk_score'].mean()
                }
            
            if self.method_vars['hybrid'].get():
                hybrid_sample = self.hybrid_sampling(self.data, target_size)
                self.comparison_results['hybrid'] = {
                    'sample': hybrid_sample,
                    'size': len(hybrid_sample),
                    'high_risk_count': len(hybrid_sample[hybrid_sample['risk_score'] > 0.7]),
                    'avg_risk': hybrid_sample['risk_score'].mean()
                }
            
            self.update_results_displays()
            self.update_coverage_analysis()
            messagebox.showinfo("Success", "Samples generated successfully")
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def update_results_displays(self):
        """Update results displays"""
        for item in self.summary_tree.get_children():
            self.summary_tree.delete(item)
        
        for method, data in self.comparison_results.items():
            display_name = method.replace('_', ' ').title()
            coverage = (data['high_risk_count'] / len(self.data[self.data['risk_score'] > 0.7]) * 100 
                       if len(self.data[self.data['risk_score'] > 0.7]) > 0 else 0)
            
            self.summary_tree.insert("", "end", text=display_name, values=(
                data['size'],
                data['high_risk_count'],
                f"{coverage:.1f}%",
                f"{data['avg_risk']:.4f}",
                self.total_strata_count
            ))
    
    def update_coverage_analysis(self):
        """Update coverage analysis"""
        entity_col = self.entity_col_var.get()
        region_col = self.region_col_var.get()
        product_col = self.product_col_var.get()
        all_cols = [entity_col, region_col, product_col] + self.selected_additional_columns
        
        for method_key, result in self.comparison_results.items():
            sample = result['sample']
            
            # Missed strata
            sample_strata = set(sample.groupby(all_cols).size().index)
            all_strata = set(self.data.groupby(all_cols).size().index)
            missed = all_strata - sample_strata
            
            tabs = self.method_coverage_tabs[method_key]
            
            # Update missed strata tree
            for item in tabs['missed_tree'].get_children():
                tabs['missed_tree'].delete(item)
            
            for stratum in missed:
                stratum_str = '_'.join(str(s) for s in stratum)
                pop_size = len(self.data[all(self.data[col] == stratum[i] for i, col in enumerate(all_cols))])
                avg_risk = self.data[all(self.data[col] == stratum[i] for i, col in enumerate(all_cols))]['risk_score'].mean()
                
                tabs['missed_tree'].insert("", "end", text=stratum_str, values=(
                    pop_size,
                    f"{avg_risk:.4f}",
                    "Small population"
                ))
            
            # Update all strata tree
            for item in tabs['all_tree'].get_children():
                tabs['all_tree'].delete(item)
            
            for stratum in all_strata:
                stratum_str = '_'.join(str(s) for s in stratum)
                stratum_data = self.data[all(self.data[col] == stratum[i] for i, col in enumerate(all_cols))]
                pop_size = len(stratum_data)
                sampled = len(sample[all(sample[col] == stratum[i] for i, col in enumerate(all_cols))])
                coverage = (sampled / pop_size * 100) if pop_size > 0 else 0
                avg_risk = stratum_data['risk_score'].mean()
                
                tabs['all_tree'].insert("", "end", text=stratum_str, values=(
                    pop_size,
                    sampled,
                    f"{coverage:.1f}%",
                    f"{avg_risk:.4f}"
                ))
    
    # ========== EXPORT FUNCTIONS ==========
    
    def export_samples(self):
        """Export samples"""
        if not self.comparison_results:
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            for method, data in self.comparison_results.items():
                filename = os.path.join(self.results_dir, f"sample_{method}.csv")
                data['sample'].to_csv(filename, index=False)
            
            messagebox.showinfo("Success", f"Samples exported to {self.results_dir}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def export_out_of_scope(self):
        """Export out of scope data"""
        messagebox.showinfo("Info", "Exporting out-of-scope data...")
    
    def export_report(self):
        """Export report"""
        messagebox.showinfo("Info", "Exporting report...")
    
    def export_all_results(self):
        """Export all results"""
        try:
            self.export_samples()
            messagebox.showinfo("Success", "All results exported")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")
    
    def update_visualizations(self):
        """Update visualization charts"""
        if not self.comparison_results:
            messagebox.showerror("Error", "Generate samples first")
            return
        
        try:
            for ax in self.axes.flatten():
                ax.clear()
            
            # Simple placeholder charts
            methods = list(self.comparison_results.keys())
            sizes = [self.comparison_results[m]['size'] for m in methods]
            
            self.axes[0, 0].bar(methods, sizes)
            self.axes[0, 0].set_title('Sample Sizes by Method')
            self.axes[0, 0].set_ylabel('Size')
            
            self.fig.tight_layout()
            self.canvas.draw()
            messagebox.showinfo("Success", "Charts updated")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {str(e)}")


def main():
    """Main entry point"""
    root = tk.Tk()
    out_dir = os.path.expanduser("~")
    app = OMRCRiskBasedSamplingTool(root, out_dir)
    root.mainloop()


if __name__ == "__main__":
    main()
